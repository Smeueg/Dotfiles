#!/bin/sh
# Basic interactive shell config that should work on every posix compliant shell
set -o vi   # Vi mode, works on most shells
[ "$(command -v stty)" ] && stty -ixon 	# Disable Ctrl-q and Ctrl-s
export HISTFILE=/tmp/shell_history


# Shell Options #
if [ "${BASH_VERSION}" ]; then
	# Bash Specific configuration
	complete -c man which
	complete -cf sudo
	shopt -s autocd
	shopt -s checkwinsize

	[ -f /usr/share/bash-completion/bash_completion ] &&
		. /usr/share/bash-completion/bash_completion
elif [ "${ZSH_NAME}" ]; then
	# Zsh Specific configuration
	setopt autocd

	bindkey -v '^H' backward-delete-char
	bindkey -v '^?' backward-delete-char
	setopt PROMPT_SUBST
fi



# PROMPT #
# Should work on dash, bash, zsh, and ksh
print_prompt() {
	ret=${?}
	symbol="âžœ"
	symbol_backup=">"
	reset="\033[0m"
	color_dir="\033[1;38;5;11m"
	color_branch="\033[38;5;8m"
	color_failed="\033[38;5;1m"
	color_success="\033[38;5;6m"

	tmp="$(tty)"
	if ! [ "${tmp%%/dev/tty*}" ] || [ "${TERM}" = "dumb" ]; then
		symbol=${symbol_backup}
	fi


	if [ "${BASH_VERSION}" ]; then
		wrapper="\001:\002"
	elif [ "${ZSH_NAME}" ]; then
		wrapper="%{:%}"
	elif ! [ "${KSH_VERSION}" ]; then
		unset reset color_dir color_branch color_failed color_success
	fi


	if [ "${wrapper+x}" ]; then
		wrapper_start=${wrapper%%\:*}
		wrapper_end=${wrapper##*\:}
		for var in reset color_dir color_branch color_failed color_success; do
			eval "${var}=\"\${wrapper_start}\$${var}\${wrapper_end}\""
		done
	fi

	# Change the directory color to red if the user doesn't have permissions to
	# write to the directory
	[ -w "${PWD}" ] || color_dir=${color_failed}

	# Current Directory
	if ! [ "${PWD%${HOME}*}" ]; then
		printf '%b%s' "${color_dir}" "~${PWD#${HOME}}"
	else
		printf '%b%s' "${color_dir}" "${PWD}"
	fi

	# Git Branch
	branch=$(git branch --show-current 2>/dev/null)
	[ "${branch}" ] && printf '%b [ %s ]' "${color_branch}" "${branch}"

	# Symbol color
	if [ ${ret} -eq 0 ]; then
		printf '\n%b%s%b ' "${color_success}" "${symbol}" "${reset}"
	else
		printf '\n%b%s%b ' "${color_failed}" "${symbol}" "${reset}"
	fi
}
export PS1="\$(print_prompt)"



# ALIASES #
alias emacs="emacs -nw"
alias mkdir="mkdir -pv"
alias diff="diff --color=always"
alias grep="grep --color=auto"
alias wget='wget --hsts-file="/tmp/wget-hsts"'
alias sxiv="sxiv -o"
alias ls="ls --color --group-directories-first"
alias mv="mv -i"
alias rm="rm -i"
alias cp="cp -i"
alias ip="ip --color=auto"

droidcam_ip="192.168.18.44"
droidcam_port="4747"
alias dra="droidcam-cli -a ${droidcam_ip} ${droidcam_port}"
alias drav="droidcam-cli -a -v ${droidcam_ip} ${droidcam_port}"
unset droidcam_ip droidcam_port



# Functions #
compress_documents() {
	if [ -d "${HOME}/Documents" ]; then
		printf "[\033[1;31mERROR\033[0m] '%s' does not exist\n" "${HOME}/Documents" >&2
		return
	fi

	if [ "$(command -v tar)" ]; then
		printf "[\033[1;31mERROR\033[0m] Command 'tar' not found\n" >&2
		return
	fi

	printf "Compressing '%s' to %s\n" "${HOME}/Documents" "${HOME}/Documents.tar.gz"
	tar cvf Documents.tar.gz ~/Documents -I "gzip --best"
}


colors() {
	# Print terminal colors
	if ! [ "${1##*[!0-9]*}" ]; then
		printf "[\033[1;31mERROR\033[0m]: Not an integer\n" >&2
		return 1
	elif [ ${1} -gt 255 ]; then
		printf "[\033[1;31mERROR\033[0m]: Number is greater than 255\n" >&2
		return 1
	fi

	i=0
	case "${1}" in
		"16") printf '\n'
			  while [ ${i} -ne 16 ]; do
				  [ ${i} -eq 8 ] && printf '\n\n'
				  printf "\033[7m\033[38;5;${i}m  \033[0m "
				  i=$((i + 1))
			  done
			  printf '\n'
			  ;;
		*) while [ ${i} -ne ${1} ]; do
			   printf "\033[7m\033[38;5;${i}m ${i} \033[0m"
			   i=$((i + 1))
		   done
		   ;;
	esac
	printf '\n'
	unset i
}


doar() { eval "su -c '$@'"; }


dit() {
	if [ "${1}" = "files" ]; then
		printf "Red means that the file exists in the repo but doesn't in this machine.\n"
		while read line; do
			if [ -f "$HOME/${line}" ]; then
				printf '~/%b\n' "${line}"
			else
				printf '\033[38;5;1m~/%b\033[0m\n' "${line}"
			fi
		done <<-EOF
		$(cd "${HOME}"; git --git-dir="${HOME}"/.local/dots/ --work-tree="${HOME}" ls-tree -r master --name-only)
		EOF
	else
		git --git-dir=$HOME/.local/dots/ --work-tree=$HOME "$@"
	fi
}


mp() {
	if ! [ "$(command -v jmtpfs)" ]; then
		printf "[\033[1;31mERROR\033[0m] Command 'jmtpfs' not found" >&2
		return 1
	fi

	if ! jmtpfs -l | { read _; read line; [ "${line}" ]; }; then
		printf "[\033[1;31mERROR\033[0m] Do device found" >&2
		return 1
	fi

	if ! [ -d "/tmp/jmtpfs" ]; then
		mkdir "/tmp/jmtpfs"
		jmtpfs "/tmp/jmtpfs"
	else
		umount "/tmp/jmtpfs"
		rmdir "/tmp/jmtpfs"
	fi
}


e() {
	if [ "${EDITOR}" = "emacs" ] && [ "$(command -v emacsclient)" ]; then
		emacsclient -a ${EDITOR} $@ &
	else
		${EDITOR} $@
	fi
}


# LESS (for man pages)
export LESS_TERMCAP_mb=$'\033[1;32m'
export LESS_TERMCAP_md=$'\033[1;32m'
export LESS_TERMCAP_so=$'\033[1;33m'
export LESS_TERMCAP_me=$'\033[0m'
export LESS_TERMCAP_se=$'\033[0m'
export LESS_TERMCAP_ue=$'\033[0m'
export LESS_TERMCAP_us=$'\033[1;4;31m'


# Nix
[ -f "${HOME}/.nix-profile/etc/profile.d/nix.sh" ] &&
	. "${HOME}/.nix-profile/etc/profile.d/nix.sh"

# Brew
[ -f "/home/linuxbrew/.linuxbrew/bin/brew" ] &&
	eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"

if ! [ "${TERM}" = "linux" ]; then
	printf '\r\033[H\033[J'
	colors 16
fi
