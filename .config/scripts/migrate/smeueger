#!/bin/sh
# ------------------------------------------------
# Script Name    - smeueger
# Author Name    - Smeueg
# Author Email   - Smeueg@gmail.com
# Author Gitlab  - https://gitlab.com/Smeueg
# Last Updated   - Thu  7 Apr 10:11:15 WIB 2022
# ------------------------------------------------
# Info:
#   The bootstraping script that makes you more Smeueg INSTANTLY.
#   Tested with bash, yash, ash, dash, and zsh
#
# TODO:
#   - Clean Up
#   - Test out full install in another system
#   - Make script ksh compatible

# Variables
export PATH="/sbin:$PATH"
WALLPAPER_DIR="${HOME}/.config/rice/"
WALLPAPER_URL="https://i.imgur.com/DVJsvfN.png"
DOTFILE_DIR="${HOME}/.local/dots"
DOTFILE_URL="https://gitlab.com/smeueg/dotfiles.git"
FONT_DIR="${HOME}/.local/share/fonts/"


# Character Variable
special="$(printf '\033')"
newline="
"
choices="
Dotfiles              {git,mv}                 | install_dotfiles
Font (JetBrainsMono)  {wget||curl}             | install_font
Wallpaper             {wget||curl}             | install_wallpaper
Nix Package Manager   {wget||curl}             | install_nix
TFL's Simplify Ubuntu {wget||curl}             | install_SU
Droidcam              {wget||curl,unzip,cc}    | install_droidcam
Mount tmpfs to /tmp   {su}                     | mktmpfs
Create Swapfile       {mkswap,swapon,dd,chmod} | mkswapfile
"

# Utility functions
error() { printf "\033[31m\033[1m[ERROR]\033[0m ${1}\033[0m\n" >&2; }
warning() { printf "\033[33m\033[1m[WARNING]\033[0m ${1}\n"; }
notice() { printf "\033[32m\033[1m[NOTICE]\033[0m ${1}\n"; }
check_depend() { [ "$(command -v "${1}")" ]; }

header() {
	str="="
	while [ ${#str} -ne $(((70-${#1})/2)) ]; do
		str="${str}="
	done
	printf '\n%s %s %s\n' "${str}" "${1}" "${str}"
}

run_as_root() {
	case "${cmd_for_root}" in
		"sudo") eval "sudo $SHELL -c '$@'" ;;
		"su") eval "su -c '$@'" ;;
		"none") error "Root isn't authenticated, unable to run '$@'" ;;
		*) if check_depend sudo && notice "checking if 'sudo' can be used" && [ "$(sudo printf 'y\n')" = "y" ]; then
			   cmd_for_root="sudo"
			   notice "Using 'sudo' to run commands with root privilages"
			   eval "sudo $SHELL -c '$@'"
		   elif check_depend su && notice "checking if 'su' can be used" && [ "$(su -c 'printf "y\n"')" = "y" ]; then
			   cmd_for_root="su"
			   notice "Using 'su -c' to run commands with root privilages"
			   eval "su -c '$@'"
		   else
			   error "Root isn't authenticated"
			   cmd_for_root="none"
		   fi
		   ;;
	esac
}

# Check for curl or wget
if check_depend curl; then
	fetch() { curl -L "${1}" -o "${2}"; }
elif check_depend wget; then
	fetch() { WGETRC= wget --no-hsts "${1}" -O "${2}"; }
fi


# Read a single character some shells, including bash and zsh, has read -n1
# which is better to use than dd. So use that if it's available
if [ "${BASH_VERSION}" ] || [ "${KSH_VERSION}" ]; then
	read_char() { IFS= read -n 1 input; }
elif [ "${ZSH_NAME}" ]; then
	emulate sh
	read_char() { IFS= read -k 1 input; }
else
	if ! check_depend "stty"; then
		error "Command 'stty' not found. Exiting"
		exit
	fi

	stty_settings=$(stty -g)
	read_char() {
		input="$(dd bs=1 count=1 2>&1)"
		input="${input%${input#?}}"
	}
fi


# Prompt user with Y or no question, with ${1} as the prompt
# Usage: `confirm "Are you sure?"` -> "Are you sure? [Y\n] "
confirm() {
	printf '%s [Y\\n] ' "${1}"
	read reply
	printf '\n'
	echo "${reply}"
	case "${reply}" in
		[Yy][Ee][Ss]|[Yy]|"") return 0 ;;
		*) return 1;;
	esac
}


# Replace $1 with $2 in $3
# Usage: `replace "foo" "bar" "foo jar bar"` ─> "bar jar bar"
replace() {
	_replace() {
		for i in ${2}; do
			str="${str}${i}${1}"
		done
		printf '%s\n' "${str%${1}}"
		unset str
	}
	IFS="${1}" _replace "${2}" "${3}"
	unset -f _replace
}


# Pick a choice interactively with ${1} being the string
# Usage: `mini_choice "$(printf 'foo\nbar\nbaz')"`
mini_choice() {
	chosen=0
	while :; do
		i=0
		while read -r line; do
			if [ ${i} -eq ${chosen%%:*} ]; then
				printf '\033[7m %s \033[0m\n' "${line}"
				chosen_line="${line}"
			else
				printf ' %s \n' "${line}"
			fi
			i=$((i+1))
		done <<-EOF
		${1}
		EOF

		read_char
		if [ "${input}" = "${special}" ]; then
			read_char
			read_char
			case "${input}" in
				"A") input="k" ;;
				"B") input="j" ;;
			esac
		fi
		stty echo

		 case "${input}" in
			 "k") [ ${chosen} -ne 0 ] && chosen=$((chosen-1));;
			 "j") [ ${chosen} -ne $((i-1)) ] && chosen=$((chosen+1));;
			 "q")
				 choice_out=""
				 return
				 ;;

			 "${newline}"|" ")
				 printf "\033[${i}A\033[J"
				 choice_out="${chosen_line}"
				 unset chosen_line chosen input i
				 return
				 ;;
		 esac
		 printf "\033[${i}A\033[J"
	 done
}



# Installation functions

dot_sync() {
	# Backup files that are different from the git repo
	printf 'Backing up existing files...\n'
	while read -r file; do
		file="${file#*$(printf '\t')}"
		dir="${HOME}/DotBackup/${file%/*}"
		file="${HOME}/${file}"

		if ! [ -d "${dir}" ] && ! mkdir --parents --verbose "${dir}"; then
			error "Failed to create directory '${dir}'\n"
			return
		fi
		mv --verbose "${file}" "${dir}"
	done <<-EOF
	$(git --git-dir=${DOTFILE_DIR} --work-tree=$HOME diff --name-status)
	EOF

	# Sync bare repo
	printf 'Syncing dotfiles...\n'
	if ! git --git-dir="${DOTFILE_DIR}" --work-tree="${HOME}" checkout; then
		error "Failed to run 'git --git-dir=${DOTFILE_DIR} --work-tree=${HOME}'"
		return
	fi
}

dot_clone() {
	# Clone as bare repo
	printf 'Cloning bare repo...\n'
	if ! git clone --bare "${DOTFILE_URL}" "${DOTFILE_DIR}"; then
		error "Failed to run 'git clone --bare ${DOTFILE_URL} ${DOTFILE_DIR}'"
		return 1
	fi
	# Do not show untracked files
	printf 'Configuring repo to not show untracked files...\n'
	if ! git --git-dir="${DOTFILE_DIR}" config status.showUntrackedFiles no; then
		warning "Failed to run 'git --git-dir=${DOTFILE_DIR} config status.showUntrackedFiles no'"
		return 1
	fi
}

install_dotfiles() {
	if ! [ "$(git --git-dir=${DOTFILE_DIR} rev-parse 2>&1)" ]; then
		printf '%s is already a git repo, overwrite?\n' "${DOTFILE_DIR}"
		mini_choice "$(printf 'Overwrite and Sync\nSync\nCancel')"
		case "${choice_out}" in
			"Overwrite and Sync")
				header "Cloning and Syncing Dotfiles"
				dot_clone
				dot_sync
				;;
			"Sync")
				header "Syncing Dotfiles"
				dot_sync
				;;
			*)
				printf "Won't do anything...\n"
				;;
		esac
		return
	fi
	header "Cloning and Syncing Dotfiles"
	dot_clone
	dot_sync
}


install_nix() {
	# Check if nix is already installed
	if check_depend nix; then
		printf 'Nix seems to already be installed (command nix found), exiting...\n'
		return
	elif [ -d /nix ]; then
		printf "Nix seems to already be installed ('/nix' exists), exiting...\n"
		return
	fi

	# Prompt for confirmation on installing in single-user mode
	if ! confirm "This will install nix in single-user mode, continue?"; then
		printf "Won't install nix...\n"
		return
	fi

	header "Installing Nix"
	if [ "$(uname)" = "Linux" ]; then
		run_as_root "mkdir -pvm 0755 /nix && chown ${USER} /nix"
		[ -d /nix ] || return
	fi

	sh -s -- --no-daemon <<-EOF
	$(curl -L https://nixos.org/nix/install)
	EOF

	# Removes the line that was added by nix's auto install script, i.e:
	# if [ -e ${HOME}/.nix-profile/etc/profile.d/nix.sh ]; then . ${HOME}/.nix-profile/etc/profile.d/nix.sh; fi # added by Nix installer
	[ -f "${HOME}/.profile" ] || return
	file="$(while IFS= read -r line; do
			 if ! [ "${line}" = "if [ -e ${HOME}/.nix-profile/etc/profile.d/nix.sh ]; then . ${HOME}/.nix-profile/etc/profile.d/nix.sh; fi # added by Nix installer" ]; then
				 printf '%s\n' "${line}"
			 fi
		 done < ${HOME}/.profile
	  )"

	printf '%s\n' "${file}" > "${HOME}/.profile"
}


install_font() {
	# Will install JetBrainsMono
	# Create directory FONT_DIR if needed
	FONT_DIR="${FONT_DIR%/}/JetBrainsMono Nerd Font"
	[ -d "${FONT_DIR}" ] ||
		mkdir --parents --verbose "${FONT_DIR}" || return

	header "Downloading Fonts"
	while read -r font; do
		[ "${font}" ] || continue
		[ "${font##*/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono/Ligatures/*}" ] && continue
		font="${font%\"*}"
		font="${font##*/}"
		while read -r line; do
			[ "${line}" ] || continue
			[ "${line##*Complete*Mono.ttf*}" ] && continue
			line="${line#*href=\"}"
			line="${line%\"*}"
			fetch "https://github.com${line%/blob/*}/raw/${line#*/blob/}" "${FONT_DIR}/JetBrainsMono Nerd Font ${font} Complete.ttf"
		done <<-EOF
		$(fetch "https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono/Ligatures/${font}/complete" -)
		EOF
	done <<-EOF
	$(fetch https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono/Ligatures -)
	EOF
}


install_wallpaper() {
	header "Downloading Wallpaper"
	[ -d "${WALLPAPER_DIR}" ] || mkdir --parents --verbose "${FONT_DIR}" ||
		return

	fetch "${WALLPAPER_URL}" "${WALLPAPER_DIR%/}/Shark Space.png"
}


install_SU() {
	header "Installing Simplify Ubuntu"
	sh <<-EOF
	$(curl -L "https://github.com/terminalforlife/Extra/raw/master/source/simplify-ubuntu/simplify-ubuntu-installer")
	EOF
}


install_droidcam() {
	header "Droidcam"
	if ! [ -d /lib/modules/$(uname -r)/build ]; then
		error "Kernel headers not found: Kernel $(uname -r)"
		return
	fi

	if [ "$(command -v droidcam-cli)" ]; then
		warning "'droidcam' is already installed"
	fi

	if [ -f "/tmp/droidcam_latest.zip" ]; then
		fetch https://files.dev47apps.net/linux/droidcam_1.8.2.zip /tmp/droidcam_latest.zip
		if ! [ -f "/tmp/droidcam_latest.zip" ]; then
			error "Failed to download droidcam zip file."
			return
		fi
	fi

	unzip /tmp/droidcam_latest.zip -d /tmp/droidcam
	run_as_root "cd /tmp/droidcam; ./install-client; ./install-sound; ./install-video"
}


mkswapfile() {
	header "Creating Swap File"
	warning "This will create a swapfile of 4Gb"
	run_as_root 'dd if=/dev/zero of=/swapfile bs=1M count=4096 status=progress; chmod 600 /swapfile; /sbin/mkswap /swapfile; /sbin/swapon /swapfile; printf "/swapfile none swap defaults 0 0\n" >> /etc/fstab'
}


mktmpfs() {
	if ! [ -f "/etc/fstab" ]; then
		error "/etc/fstab doesn't exist, exiting."
		return
	fi

	header "TMPFS"
	warning "This will mount tmpfs with a size of 512M to /etc/fstab"
	while IFS= read -r line; do
		[ "${line%%tmpfs*/tmp*tmpfs*}" ] && continue
		warning "Seems like '/tmp' is already mounted as tmpfs"
		break
	done < /etc/fstab

	printf 'Do you want to continue? [Y\\n] '
	read reply
	case "${reply}" in
		[Yy][Ee][Ss]|[Yy]|"") ;;
		*)
			printf 'Exiting.\n'
			return ;;
	esac
	printf "Adding tmpfs to '/etc/fstab'\n"
	su -c 'printf "tmpfs   /tmp         tmpfs   rw,nodev,nosuid,size=512M          0  0\n" >>/etc/fstab'
}


# MAIN SELECTION #
# Check Dependencies
while read -r line; do
	[ "${line}" ] || continue
	deps="${line#*\{}"
	deps="${deps%\}*}"
	deps_satisfied=:
	for dep in $(replace "," " " "${deps}"); do
		if ! [ "${dep##*||*}" ]; then
			deps_satisfied=false
			for dep in $(replace "||" " " "${dep}"); do
				if [ "$(command -v "${dep}")" ]; then
					deps_satisfied=:
					break
				fi
			done
		elif ! [ "$(command -v "${dep}")" ]; then
			deps_satisfied=false
			break
		fi
	done


	# Format Choices
	[ "${tmp}" ] && tmp="${tmp}\n"
	if ${deps_satisfied}; then
		tmp="${tmp}[ ] ${line}"
	else
		tmp="${tmp}[-] ${line}"
		line="${line%%\{*}"
		line="${line%${line##*[! ]}} "
	fi
done <<EOF
${choices}
EOF

choices=$(printf "${tmp}\nContinue\n")
unset tmp

warning "If the script fails and the terminal is acting strange, please run 'stty icanon echo'"
printf '\033[32m\033[1mj/↓:Down  k/↑:Up  q:quit  Enter/Space:Select\033[0m\n'
printf 'Options:\n'
chosen=0


# Get column position
stty_settings_2=$(stty -g)
stty -icanon -echo
printf "\033[6n"
while :; do
	read_char
	[ "${input}" = "R" ] && break
	row="${row}${input}"
done
row="${row#*\[}"
row="${row%;*}"
stty "${stty_settings_2}"


# Restore stty settings when ctrl-c'ing
if [ "${stty_settings}" ]; then
	stty -icanon
	trap 'stty "${stty_settings}"; exit 1' INT
fi
while :; do
	i=0
	while read -r line; do
		# Highlight Chosen Line
		if [ "${line%${line#???}}" = "[-]" ]; then
			printf '\033[31m'
			deps="${line%%\}*}"
			deps="${deps##*\{}"
			deps="$(replace "||" " or " "${deps}")"
			deps="$(replace ',' '|' "${deps}")"
			line="${line%%\{*}"
			line="${line%${line##*[! ]}} "
			line="${line} (Dependencies: ${deps})"
		else
			line="${line%%\{*}"
			line="${line%${line##*[! ]}} "
		fi

		if [ ${i} -eq ${chosen} ]; then
			printf '\r\033[7m %s\033[0m\n' "${line}"
		else
			printf '\r%s\033[0m\n' "${line}"
		fi
		i=$((i+1))
	done <<-EOF
	${choices}
	EOF

	read_char
	if [ "${input}" = "${special}" ]; then
		read_char
		read_char
		case "${input}" in
			"A") input="k" ;;
			"B") input="j" ;;
		esac
	fi


	case "${input}" in
		"k") [ ${chosen} -ne 0 ] && chosen=$((chosen-1));;
		"j") [ ${chosen} -ne $((i-1)) ] && chosen=$((chosen+1));;
		"q") printf "\033[$((row - 2));1H\r\033[J"
			 choices=""
			 break
			 ;;

		"${newline}"|" "|$'\n'|"")
			if [ ${chosen} -eq $((i-1)) ]; then
				printf "\033[2A\033[${i}A\033[J"
				break
			fi

			# Toggle chosen option
			j=0
			unset tmp
			while read -r line; do
				if [ "${j}" -ne "${chosen}" ]; then
					tmp="${tmp}${newline}${line}"
					j=$((j+1))
					continue
				fi

				if [ "${line%${line#???}}" = "[X]" ]; then
					tmp="${tmp}${newline}[ ]${line#???}"
				elif [ "${line%${line#???}}" = "[ ]" ]; then
					tmp="${tmp}${newline}[X]${line#???}"
				else
					tmp="${tmp}${newline}${line}"
				fi

				j=$((j+1))
			done <<-EOF
			${choices}
			EOF
			choices=$(printf '%s' "${tmp#?}")
			;;
	esac
	printf "\033[${row};1H\r\033[J"
done

# Restore default stty settings
if [ "${stty_settings}" ]; then
	stty "${stty_settings}"
fi


run_scripts() {
	for line in ${choices}; do
		[ "${line%%\[X\]*}" ] && continue
		"${line#*| }"
	done
}

IFS="${newline}" run_scripts
