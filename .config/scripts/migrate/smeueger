#!/bin/sh
# ------------------------------------------------
# Script Name    - smeueger
# Author Name    - Smeueg
# Author Email   - Smeueg@gmail.com
# Author Gitlab  - https://gitlab.com/Smeueg
# Last Updated   - Sat  9 Apr 17:59:44 WIB 2022
# ------------------------------------------------
# Variables #
opts="\
== Rice ==
Dotfiles              [git,mv]                          | install_dotfiles
Font (JetBrainsMono)  [wget|curl]                       | install_font
Wallpaper             [wget|curl]                       | install_wallpaper
== System Config ==
Nix Package Manager   [wget|curl]                       | install_nix
TFL's Simplify Ubuntuaaaaaaaaaaaaaaaaaaa [wgt|crl]                       | install_SU
Droidcam              [sudo|su,wget|curl,unzip,cc,make] | install_droidcam
Mount tmpfs to /tmp   [sudo|su]                         | mktmpfs
Create Swapfile       [sudo|su,mkswap,swapon,dd,chmod]  | mkswapfile"
opts_chosen_line=1
opts_chosen_tab=1



# Utility Functions #
error() { printf '\033[1m\033[31m[ERROR]\033[0m %s\n' "${1}"; }
warning() { printf '\033[1m\033[33m[ERROR]\033[0m %s\n' "${1}"; }
notice() { printf '\033[1m\033[32m[NOTICE]\033[0m %s\n' "${1}"; }

if [ "${BASH_VERSION}" ] || [ "${KSH_VERSION}" ]; then
	read_char() { IFS= read -n 1 opts_input; }
elif [ "${ZSH_NAME}" ]; then
	emulate sh
	read_char() { IFS= read -k 1 opts_input; }
else
	if ! [ "$(command -v stty)" ]; then
		error "Command 'stty' not found."
		exit
	fi

	if ! [ "$(command -v dd)" ]; then
		error "Command 'dd' not found."
		exit
	fi

	stty_settings=$(stty -g)
	read_char() {
		opts_input="$(dd bs=1 count=1 2>&1)"
		opts_input="${opts_input%${opts_input#?}}"
	}
fi

get_cur_row() {
	# Get current cursor row
	[ "${stty_settings+x}" ] && stty -icanon
	printf '\033[6n'
	while :; do
		read_char
		[ "${opts_input}" = "R" ] && break
		row="${row}${opts_input}"
	done
	row="${row#*\[}"
	row="${row%;*}"
	[ "${stty_settings+x}" ] && stty "${stty_settings}"
	printf '\r\033[2K'
}

printn() {
	# print ${1}, ${2} times
	i=0
	while [ ${i} -ne ${2} ]; do
		printf '%s' "${1}"
		i=$((i+1))
	done
	unset i
}





# UI Functions #
opts_setup() {
	opts_tab_count=0
	# Setup the options to determine whether the dependencies are met
	_handle_or() {
		for opt_dep in $1; do
			[ "$(command -v ${opt_dep})" ] || continue
			opt_has_deps=:
		done
	}

	_handle_comma() {
		for opt_dep in $1; do
			if ! [ "${opt_dep##*\|*}" ]; then
				IFS="|" _handle_or "${opt_dep}"
			elif ! [ "$(command -v ${opt_dep})" ]; then
				opt_has_deps=false
				return
			else
				opt_has_deps=:
			fi
		done
	}

	# Check if dependencies are met
	for opt in ${opts}; do
		if ! [ "${opt%%== * ==}" ]; then
			opt_tmp="${opt_tmp} Continue ${newline}${opt}${newline}"
			opts_tab_count=$((opts_tab_count + 1))
			continue
		fi
		opt_has_deps=false
		opt_deps="${opt#*\[}"
		opt_deps="${opt_deps%\]*}"
		IFS="," _handle_comma "${opt_deps}"

		opt_front_tmp="${opt%%\[*}"
		opt_front_tmp="${opt_front_tmp%${opt_front_tmp##*[! ]}}"
		opt_back_tmp="${opt##*\|}"
		opt_back_tmp="${opt_back_tmp# }"

		if ${opt_has_deps}; then
			opt_tmp="${opt_tmp} [ ] ${opt_front_tmp}"
		else
			opt_tmp="${opt_tmp}\033[31m [-] ${opt_front_tmp} [Dependencies: ${opt_deps}]"
		fi

		opt_tmp="${opt_tmp} \033[0m|${opt_back_tmp}${newline}"
	done
	opts="${opt_tmp} Continue "
	unset -f _handle_comma _handle_or
	unset opt_has_deps opt_dep opt_front_tmp opt_back_tmp
	get_cur_row
}


opts_print() {
	# Get Height and Width for the current tab
	opts_tmp_line=0
	opts_tmp_tab=0
	opts_tmp_width=52
	for opt in ${opts}; do
		if ! [ "${opt##== * ==}" ]; then
			opts_tmp_tab=$((opts_tmp_tab + 1))
			continue
		fi

		if [ ${opts_tmp_tab} -eq ${opts_chosen_tab} ]; then
			opts_tmp_line=$((opts_tmp_line + 1))
			opt="${opt%\\033*}"
			opt="${opt#*\\033[31m}"
			[ ${#opt} -gt ${opts_tmp_width} ] && opts_tmp_width=${#opt}
		fi
	done
	opts_height=${opts_tmp_line}
	opts_width=$((opts_tmp_width + 5))
	unset opts_tmp_line opts_tmp_tab opts_tmp_width

	# Actually Print
	opts_tmp_tab=0
	opts_tmp_line=0
	opts_tmp_header=""
	opts_tmp_str=""
	opts_tmp_line_str=$(printn "─" $((opts_width - 3)))

	printf "\r\033[J${opts_tmp_line_str}╮\n%${opts_width}s\r│\n" "│"
	for opt in ${opts}; do
		if ! [ "${opt%%== * ==}" ]; then
			opts_tmp_tab=$((opts_tmp_tab + 1))
			opts_tmp_line=0

			opt_tmp=${opt#== }
			opt_tmp=${opt_tmp% ==}
			if [ ${opts_tmp_tab} -eq ${opts_chosen_tab} ]; then
				opt_tmp="\033[7m\033[1m${opt_tmp}"
			fi
			opts_tmp_header="${opts_tmp_header} \033[31m${opt_tmp}\033[0m ─"
			continue
		fi

		opts_tmp_line=$((opts_tmp_line + 1))
		if [ ${opts_tmp_tab} -eq ${opts_chosen_tab} ]; then
			if [ ${opts_tmp_line} -eq ${opts_chosen_line} ]; then
				printf "%${opts_width}s\r│ \033[7m${opt%\|*}\n" "│"
			else
				printf "%${opts_width}s\r│ ${opt%\|*}\n" "│"
			fi
		fi
	done
	opts_tmp_header="\033[0m╭──${opts_tmp_header}"

	# footer
	printf "\
\033[${row};0H${opts_tmp_header}\033[${opts_height}B
\n%${opts_width}s\r│\n${opts_tmp_line_str}┤\
\r\033[0m├── \033[33mj/↓:Down\033[0m ─ \033[33mk/↑:Up\033[0m ─ \033[33mq:quit\033[0m ─ \033[33mEnter/Space:Select\033[0m ─
${opts_tmp_line_str}╯\r╰── \033[33mh/←:Select Left Tab\033[0m ─ \033[33ml/→:Select Right Tab\033[0m \n
" "│"
	unset opts_tmp_tab opts_tmp_line opt_tmp
}

opts_select() {
	opts_tmp_tab=0
	opts_tmp_line=0
	opts_tmp=""
	for opt in ${opts}; do
		if ! [ "${opt%%== * ==}" ]; then
			opts_tmp_tab=$((opts_tmp_tab + 1))
			opts_tmp_line=0
			opts_tmp="${opts_tmp}${opt}${newline}"
			continue
		fi

		opts_tmp_line=$((opts_tmp_line + 1))
		if [ ${opts_tmp_line} -eq ${opts_chosen_line} ] && [ ${opts_tmp_tab} -eq ${opts_chosen_tab} ]; then
			if ! [ "${opt%% Continue }" ]; then
				opts_run=false
			elif ! [ "${opt%% \[X\]*}" ]; then
				opts_tmp="${opts_tmp} [ ]${opt# \[X\]}${newline}"
			elif ! [ "${opt%% \[ \]*}" ]; then
				opts_tmp="${opts_tmp} [X]${opt# \[ \]}${newline}"
			else
				opts_tmp="${opts_tmp}${opt}${newline}"
			fi
		else
			opts_tmp="${opts_tmp}${opt}${newline}"
		fi
	done
	opts="${opts_tmp}"
	[ ${opts_chosen_line} -ne ${opts_height} ] && opts_chosen_line=$((opts_chosen_line + 1))
	unset opts_tmp_tab opts_tmp_line opts_tmp
}

opts_handle_keypress() {
	if [ "${stty_settings+x}" ]; then
		stty -icanon
	fi

	opts_run=:
	while ${opts_run}; do
		read_char

		if [ "${opts_input}" = "$(printf '\033')" ]; then
		 	read_char
		 	read_char
		 	case "${opts_input}" in
		 		"A") opts_input="k";;
		 		"B") opts_input="j";;
		 		"C") opts_input="l";;
		 		"D") opts_input="h";;
		 	esac
		fi

		case "${opts_input}" in
		 	"h") [ ${opts_chosen_tab} -ne 1 ] && opts_chosen_tab=$((opts_chosen_tab - 1)); opts_chosen_line=1;;
		 	"k") [ ${opts_chosen_line} -ne 1 ] && opts_chosen_line=$((opts_chosen_line - 1));;
		 	"j") [ ${opts_chosen_line} -ne ${opts_height} ] && opts_chosen_line=$((opts_chosen_line + 1));;
		 	"l") [ ${opts_chosen_tab} -ne ${opts_tab_count} ] && opts_chosen_tab=$((opts_chosen_tab + 1)); opts_chosen_line=1;;
			"q") opts_run=false ;;
			" "|${newline}||"") IFS=${newline} opts_select;;
		esac
		printf "\033[${row};0H"
		IFS=${newline} opts_print
	done
	printf "\033[${row};0H\033[J"
	unset opts_run
}


special=$(printf '\033')
newline="
"

IFS=${newline} opts_setup
IFS=${newline} opts_print
opts_handle_keypress
notice "Installation functions not implemented yet :)"
