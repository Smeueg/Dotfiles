#!/bin/python

# smeueger: Become more smeueg with this script
#
# This script is basically just a migration script using
# curses that makes migrating my *personal* dotfiles easier
# Python2 *should* be supported as well

# TODO
# - Add a are you sure menu

import sys
import os
try:
    from urllib.request import Request, urlopen
except:
    from urllib2 import Request, urlopen

# Variables #
message = (
        "Underline means the dependency or dependencies are not meant.",
        "k: UP  j: DOWN,  a: Select All or arrow keys",
        "G: Go to bottom  g: Go to Top"
    )

home      = os.environ["HOME"]
dotDir    = home + "/.local/dots"
dotBackup = home + "/dotBackup"
dotURL    = "https://gitlab.com/Smeueg/Dotfiles.git"

wallpaperDir = home + "/.local/rice/Wallpapers"
wallpapers   = {
        "Rock Thing.png"  : "https://images2.alphacoders.com/950/950452.png",
        "Red Space.jpg"   : "https://cdna.artstation.com/p/assets/images/images/004/085/784/large/starkiteckt-designs-untitled-2.jpg?1480219852",
        "Warm Mountain.jpg" : "https://i.redd.it/odrdq4yqtoz61.jpg"
}

sucklessDir = home + "/.local/rice"
fontsDir    = home + "/.local/share/fonts"

# Utilities #
def DownloadFile(url, file):
    if file[-1] == "/":
        file += url.split("/")[-1]

    req = Request(url, headers={'User-Agent': 'Mozilla/5.0'})

    with open(file, 'wb') as f:
        f.write(urlopen(req).read())


def Confirm(string):
    if not string.endswith("[Y/n] "):
        if string[-1] != " ":
            string += " "
        string += "[Y/n] "

    try:
        inputFunc = raw_input
    except:
        inputFunc = input

    confirmation = inputFunc(string).lower()

    if confirmation == "" or confirmation == "y" or confirmation == "yes":
        return True

    return False


# Get a file from the latest github release
def GithubRegex(repoUrl, regex):
    import re
    if repoUrl[-1] != "/":
        repoUrl += "/"

    repoUrl = Request(repoUrl + "releases", headers={"User-Agent": "Mozilla/5.0"})
    repoUrl = urlopen(repoUrl).read()

    if type(repoUrl) != str:
        repoUrl = repoUrl.decode()

    latestTag = re.findall("(?<=/releases/tag/).*(?=\")", repoUrl)[0]

    files = []
    for file in re.findall('(?<=href="){}(?=")'.format(regex), repoUrl):
        if latestTag in file:
            files.append("https://github.com" + file)

    return files


# Capture/return a command
def GetCmd(arr):
    import subprocess
    out = subprocess.Popen(arr, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out = out.communicate()
    stdout = out[0]
    stderr = out[1]

    if type(stdout) == bytes:
        stdout = stdout.decode()

    if type(stderr) == bytes:
        stderr = stderr.decode()

    return {"stdout":stdout, "stderr":stderr}



def CheckVersion():
    print("Checking python version...")

    version = sys.version_info
    msg = "This version of python ({}.{}.{}) is not supported, please install a higher version (2.6 or above)".format(version.major, version.minor, version.micro)

    if version.major == 3:
        return
    elif version.major == 2:
        if version.minor < 6:
            print(msg)
            sys.exit(-1)
        else:
            return
    else:
        print(msg)
        sys.exit(-1)


def CheckInternet():
    import socket

    print("Checking internet connection")
    try:
        socket.create_connection(("1.1.1.1", 53))
        return
    except:
        print("You do not have an internet connetion... Exiting")
        sys.exit(-1)


def CheckOS():
    from sys import platform
    unsupportedOS = ("win32", "cygwin", "msys")
    if platform in unsupportedOS:
        print("No. Windows is garbage.")
        sys.exit(-1)


def CheckCompiler():
    for dir in os.environ['PATH'].split(':'):
        if os.access("{}/cc".format(dir), os.X_OK):
            return

    print("WARNING: `cc`, usually symlinked to `gcc`, is not installed...")
    if not Confirm("Do you want to continue?"):
        sys.exit(1)



# UI #
import curses
stdscr = None
menu   = None

def drawMsg(menuY):
    global stdscr
    if stdscr == None:
        stdscr = curses.initscr()

    msgAmount = len(message)
    for i in range(msgAmount):
        stdscr.addstr(int(menuY-msgAmount+i), int((stdscr.getmaxyx()[1] - len(message[i])) / 2), message[i])

    stdscr.refresh()


def drawMenu(choices, isSubmenu):
    global stdscr
    global menu

    menuH = len(choices)
    menuW = 0

    for choice in choices:
        if len(choice.name) > menuW:
            menuW = len(choice.name)

    if stdscr == None:
        stdscr = curses.initscr()

    menuH += 2
    menuW += 7
    menuY = (stdscr.getmaxyx()[0] - menuH) / 2
    menuX = (stdscr.getmaxyx()[1] - menuW) / 2

    if menu == None:
        menu = curses.newwin(0, 0)
        menu.keypad(True)

    menu.resize(menuH, menuW)
    menu.mvwin(int(menuY), int(menuX))
    menu.box()
    drawMsg(menuY)

    highlighted = 0

    # Main Loop
    while True:
        highlightedOffset = 1

        # Draw choices
        for index in range(menuH - 1):
            attr = [curses.A_NORMAL, curses.A_REVERSE][highlighted == index]

            if index != len(choices):
                offset = 1
                choice = choices[index]

                if choice.missingDep["progs"] != [] or choice.missingDep["libs"] != []:
                    attr = attr | curses.A_UNDERLINE

                if choice.submenu == None:
                    string = "[" + [" ", "X"][choices[index].toggled] + "]"
                else:
                    string = " * "

                string += " " + choices[index].name + " "
            else:
                string = [" CONTINUE ", " BACK "][isSubmenu]
                offset = int((menuW - len(string)) / 2)

            if highlighted == index:
                highlightedOffset = offset

            menu.addstr(index + 1, offset, string, attr)

        # Move cursor to a "hidden" place
        menu.move(highlighted+1, highlightedOffset)

        key = menu.getkey()


        if key == "j" or key == "KEY_DOWN":
            highlighted += (highlighted != menuH-2)

        elif key == "k" or key == "KEY_UP":
            highlighted -= (highlighted != 0)

        elif key == "g":
            highlighted = 0

        elif key == "G":
            highlighted = menuH - 2

        elif key == "q" or ord(key) == 27: # Esc or q
            curses.endwin()
            sys.exit(1)

        elif key == "a":
            selectedAll = True
            for choice in choices:
                if not choice.toggled and not choice.submenu:
                    selectedAll = False
                    break

            for choice in choices:
                if choice.submenu == None:
                    choice.toggled = not selectedAll

        elif key == "\n" or key == " " or key == "KEY_RIGHT":
            if highlighted == menuH-2:
                menu.clear()
                menu.refresh()
                return True

            if choices[highlighted].missingDep["progs"] != [] or choices[highlighted].missingDep["libs"]:
                continue

            if choices[highlighted].submenu == None:
                choices[highlighted].toggled = not choices[highlighted].toggled
            else:
                # Clear the window
                menu.clear()
                menu.refresh()
                stdscr.clear()
                stdscr.refresh()
                drawMenu(choices[highlighted].submenu, True)
                stdscr.clear()
                menu.clear()
                # Redraw window
                menu.resize(menuH, menuW)
                menu.mvwin(int(menuY), int(menuX))
                menu.box()
                drawMsg(menuY)

        elif key == "KEY_LEFT":
            menu.clear()
            menu.refresh()
            return True

def handleCtrlC(signal, frameType):
    if not curses.isendwin():
        curses.endwin()

    sys.exit(signal)

import signal
signal.signal(signal.SIGINT, handleCtrlC)
# -- #


# Main Code #
class Choice:
    def __init__(self, name, submenu, func, arg, deps):
        self.name    = name
        self.submenu = submenu
        self.func    = func
        self.arg     = arg
        self.deps    = deps
        self.toggled = False


        # Dependency Checking #
        self.missingDep = {
            "progs" : [],
            "libs"  : []
        }

        if self.deps != None:
            progs = self.deps.get("progs")
            libs  = self.deps.get("libs")

            path = os.environ["PATH"]
            if progs != None:
                if type(progs) == str:
                    progs = [progs]

                for file in progs:
                    found = False
                    for directory in path.split(":"):
                        if directory[-1] != "/":
                            directory += "/"

                        if os.access(directory + file, os.X_OK):
                            found = True

                    if not found:
                        self.missingDep["progs"].append(file)

            found = False
            if libs != None:
                if type(libs) == str:
                    libs = [libs]

                for directory in path.split(":"):
                    if directory[-1] != "/":
                        directory += "/"

                    if os.access(directory + file, os.X_OK):
                        found = True

                if not found:
                    for lib in libs:
                        self.missingDep["libs"].append("lib" + lib)

                    return

                cmd = ["cc"]

                for lib in libs:
                    cmd.append("-l" + lib)

                err = GetCmd(cmd)["stderr"]
                for lib in libs:
                    if "cannot find -l" + lib in err:
                        self.missingDep["libs"].append("lib" + lib)


    def execute(self):
        if self.func == None and self.submenu == None:
            return

        submenuExec = False
        if self.submenu != None:
            for choice in self.submenu:
                if choice.toggled:
                    choice.execute()
                    submenuExec = True

        if (self.toggled or submenuExec) and self.func != None:
            if self.arg == None:
                self.func()
            else:
                self.func(self.arg)


def CheckDep(choices):
    missing = {}

    def CheckMenu(menu, prevMenu):
        for choice in menu:
            for depType in choice.missingDep:
                for dep in choice.missingDep[depType]:
                    string = choice.name

                    if prevMenu != None:
                        string += "\033[4m\033[1m\033[3m in \033[0m" + prevMenu.name

                    if missing.get(dep) == None:
                        missing[dep] = [string]
                    else:
                        missing[dep].append(string)

            if choice.submenu != None:
                CheckMenu(choice.submenu, choice)

    CheckMenu(choices, None)

    if missing == {}:
        return True

    print("!! WARNING !!")
    for dep in missing:
        print(dep + " is needed to install:")
        for name in missing[dep]:
            print("  - " + name)
        print("")

    return Confirm("Do you want to continue?")
# --------- #


# Dotfiles #
def GetDot():
    if os.path.isdir(dotDir):
        print("Target directory exists, Will not install dotfiles...")
        return

    print("\n\nDownloading dotfiles...")
    os.system("git clone --bare {} {}".format(dotURL, dotDir))

    output = GetCmd(["git", "--git-dir=" + dotDir, "ls-tree", "-r", "HEAD"])["stdout"]
    output = "{}".format(output)

    for line in output.splitlines():
        file = line.split("\t")[1]

        if os.path.isfile(home + "/" + file):
            import shutil

            directory = dotBackup + "/" + "/".join(file.split("/")[:-1])
            if not os.path.isdir(directory):
                os.makedirs(directory)
                print("Made directory: " + directory)

            shutil.move(home + "/" + file, directory)

    os.system("git --git-dir={} --work-tree={} checkout".format(dotDir, home))
    os.system("git --git-dir={} config status.showUntrackedFiles no".format(dotDir))
    print("Downloaded dotfiles!")
# -------- #



# Wallpapers #
def GetWallpapers():
    global wallpaperDir

    print("NOTICE: I DO NOT OWN NOR HAVE MADE ANY OF THE WALLPAPERS NOR FONT, ALL CREDIT GOES TO THE RESPECTIVE ARTIST/CREATORS")
    print("Getting wallpaper(s)...")
    if not os.path.isdir(wallpaperDir):
        print("Made directory: " + wallpaperDir)
        os.makedirs(wallpaperDir)

    if wallpaperDir[-1] != "/":
        wallpaperDir += "/"

    for file in wallpapers:
        DownloadFile(wallpapers[file], wallpaperDir + file)
        print("Downloaded " + file)
# ---------- #


# Suckless #
def GetSuckless(arg):
    if type(arg) == str:
        url     = arg
        regex   = None
        patches = None
    else:
        url     = arg[0]
        regex   = arg[1]
        patches = arg[2]

    if regex != None:
        url = GithubRegex(url, regex)[0]


    print("Downloading {}...".format(url.split("/")[-1]))
    dest = url.split("/")[-1]
    if url.endswith(".git"):
        dest      = dest[:-4]
        dest      = sucklessDir + "/" + dest

        if os.path.isdir(dest):
            print("Will not install {}, directory exists...".format(dest))
            return

        patchDest = dest
        os.system("git clone {} {}".format(url, dest))

    elif url.endswith(".tar.gz"):
        from io import BytesIO
        import tarfile
        tar = Request(url, headers={"User-Agent": "Mozilla/5.0"})
        tar = urlopen(tar).read()
        tar = tarfile.open(fileobj=BytesIO(tar))

        dirAmount = 0
        for member in tar.getmembers():
            if member.isdir():
                dirAmount += 1

        if dirAmount == 1:
            dest = sucklessDir
            patchDest = sucklessDir + "/" + tar.getmembers()[0].name
        else:
            dest      = sucklessDir + dest[:-7]
            patchDest = dest

        if not os.path.isdir(dest):
            os.makedirs(dest)

        if not os.path.isdir(patchDest):
            tar.extractall(dest)
            tar.close()
        else:
            tar.close()
            print("Will not install {}, directory exists...".format(patchDest))
            return
    else:
        return

    if patches == None:
        return

    if patchDest[-1] != "/":
        patchDest += "/"

    for patch in patches:
        DownloadFile(patch, patchDest)
        os.system("patch -d {} < {}".format(patchDest, patchDest + "/" + patch.split("/")[-1]))


def CompileSuckless():
    if Confirm("Do you with to compile all of your suckless Utilities (You need root privilages)?"):
        import termios
        import sys
        fd = sys.stdin.fileno()
        default = termios.tcgetattr(fd)
        os.system("su -c 'for dir in {}/*/*[Mm]akefile; do make install -C $(dirname $dir); done'".format(sucklessDir))
        termios.tcsetattr(fd, termios.TCSADRAIN, default)
# -------- #


# Fonts #
def GetFonts(arg):
    from zipfile import ZipFile
    from io import BytesIO
    url       = [arg[0]]
    regex     = arg[1]
    directory = arg[2]


    if directory == None or directory == "":
        directory = fontsDir
    else:
        directory = fontsDir + "/" + directory

    if directory[-1] != "/":
        directory += "/"

    if not os.path.isdir(directory):
        os.makedirs(directory)

    if regex != "" and regex != None:
        url = GithubRegex(url[0], regex)

    for file in url:
        print("Downloading {}...".format(file.split("/")[-1]))
        if file.endswith(".zip"):
            zipData = Request(file, headers={"User-Agent": "Mozilla/5.0"})
            zipData = urlopen(zipData)
            zipData = ZipFile(BytesIO(zipData.read()))
            zipData.extractall(directory)
        else:
            DownloadFile(file, directory)


CheckInternet()
CheckVersion()
CheckOS()
CheckCompiler()
print("Checking dependencies...")

suckless = (
    Choice("Dynamic Window Manager", None, GetSuckless, "https://gitlab.com/Smeueg/dwm.git",
        {"progs":"git","libs":["X11", "Xinerama", "fontconfig", "Xft"]}),

    Choice("Simple Terminal", None, GetSuckless, "https://gitlab.com/Smeueg/st.git",
        {"progs":"git","libs":["X11", "Xft", "Xrender"]}),

    Choice("DwmBlocks", None, GetSuckless, "https://gitlab.com/Smeueg/dwmblocks.git",
        {"progs":"git","libs":"X11"}),

    Choice("Herbe", None, GetSuckless, [
            "https://github.com/dudik/herbe",
            ".*.tar.gz",
            (
                "https://patch-diff.githubusercontent.com/raw/dudik/herbe/pull/11.diff",
                "https://patch-diff.githubusercontent.com/raw/dudik/herbe/pull/19.diff"
            )
        ], {"progs":"patch","libs":["X11","Xft"]}),

    Choice("Slock", None, GetSuckless, [
            "https://dl.suckless.org/tools/slock-1.4.tar.gz",
            None,
            (
                "https://tools.suckless.org/slock/patches/foreground-and-background/slock-foreground-and-background-20210611-35633d4.diff",
                "https://gitlab.com/Smeueg/dotfiles/-/raw/master/.local/rice/misc/slockConfig.diff"
            )
        ], {"progs":"patch","libs":["X11", "Xinerama", "Xft", "Xext", "Xrandr", "Imlib2"]}),

    Choice("Devour", None, GetSuckless,
        ["https://github.com/salman-abedin/devour", ".*.tar.gz", None],
        {"libs":"X11"})
)

fonts = (
    Choice("JetBrains Mono", None, GetFonts, (
            "https://github.com/JetBrains/JetBrainsMono",
            ".*JetBrainsMono\\-.*.zip",
            "JetBrainsMono"
        ),
        None),

    Choice("Material Icons", None, GetFonts, (
            "https://github.com/google/material-design-icons/raw/master/font/MaterialIcons-Regular.ttf",
            None,
            None),
        None),
    Choice("Noto Color Emoji", None, GetFonts, (
            "https://noto-website-2.storage.googleapis.com/pkgs/NotoColorEmoji-unhinted.zip",
            None,
            "NotoColorEmoji"),
        None)
)


mainChoice = (
    Choice("Dotfiles",                None,     GetDot,          None, {"progs":"git"}),
    Choice("Wallpaper(s)",            None,     GetWallpapers,   None, None),
    Choice("Suckless(-ish) Programs", suckless, CompileSuckless, None, {"progs":["make", "gcc"]}),
    Choice("Fonts",                   fonts,    None,            None, None),
)


if not CheckDep(mainChoice):
    sys.exit(-1)

execute = drawMenu(mainChoice, False)
curses.endwin()

if execute:
    for choice in mainChoice:
        choice.execute()
