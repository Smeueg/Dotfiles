#!/bin/sh
# ------------------------------------------------
# Script Name    - smeueger
# Author Name    - Smeueg
# Author Email   - Smeueg@gmail.com
# Author Gitlab  - https://gitlab.com/Smeueg
# Last Updated   - Thu 14 Apr 09:59:53 WIB 2022
# ------------------------------------------------
# Variables #
opts="\
== Rice ==
Dotfiles              [git,mv]     | install_dotfiles
Font (JetBrainsMono)  [wget|curl]  | install_font
Wallpaper             [wget|curl]  | install_wallpaper
== System Config ==
Droidcam              [sudo|su,wget|curl,unzip,cc,make,uname] | install_droidcam
Nix Package Manager   [wget|curl]                             | install_nix
TFL's Simplify Ubuntu [wget|curl]                             | install_SU
TFL's Ubuchk          [wget|curl]                             | install_ubuchk
Mount tmpfs to /tmp   [sudo|su]                               | mktmpfs
Create Swapfile       [sudo|su,mkswap,swapon,dd,chmod]        | mkswapfile
"
opts_chosen_line=1
opts_chosen_tab=1

newline="
"

# If apt exists, add extra apt specific options
if [ "$(command -v apt)" ]; then
	opts="${opts}${newline}== Debian Misc Packages ==${newline}"
	opts="${opts}Enable Brave Browser [sudo|su,wget|curl,dpkg] | apt_enable_brave${newline}"
	opts="${opts}Bootstrap Packages   [sudo|su]                | apt_bootstrap_packages${newline}"
fi



# Utility Functions #
error() { printf '[\033[1m\033[31mERROR\033[0m] %s\n' "${1}"; }
warning() { printf '[\033[1m\033[33mWARNING\033[0m] %s\n' "${1}"; }
notice() { printf '[\033[1m\033[32mNOTICE\033[0m] %s\n' "${1}"; }

if [ "${BASH_VERSION}" ] || [ "${KSH_VERSION}" ]; then
	read_char() { IFS= read -n 1 opts_input; }
elif [ "${ZSH_NAME}" ]; then
	emulate sh
	read_char() { IFS= read -k 1 opts_input; }
else
	if ! [ "$(command -v stty)" ]; then
		error "Command 'stty' not found."
		exit
	fi

	if ! [ "$(command -v dd)" ]; then
		error "Command 'dd' not found."
		exit
	fi

	stty_settings=$(stty -g)
	read_char() {
		opts_input="$(dd bs=1 count=1 2>&1)"
		opts_input="${opts_input%${opts_input#?}}"
	}
fi

if [ "$(command -v curl)" ]; then
	fetch() { curl -L "${1}" -o "${2}"; }
elif [ "$(command -v wget)" ]; then
	fetch() { wget --no-hsts "${1}" -O "${2}"; }
fi

get_cur_row() {
	# Get current cursor row
	[ "${stty_settings+x}" ] && stty -icanon
	printf '\033[6n'
	while :; do
		read_char
		[ "${opts_input}" = "R" ] && break
		row="${row}${opts_input}"
	done
	row="${row#*\[}"
	row="${row%;*}"
	[ "${stty_settings+x}" ] && stty "${stty_settings}"
	printf '\r\033[2K'
}

printn() {
	# print ${1}, ${2} times
	i=0
	while [ ${i} -ne ${2} ]; do
		printf '%s' "${1}"
		i=$((i+1))
	done
	unset i
}

confirm() {
	# Prompt the user for a yes or no question, displaying ${1} as the question
	printf '%s [Y\\n] ' "${1}"
	read reply
	case "${reply}" in
		[Yy][Ee][Ss]|[Yy]|"") unset reply; return 0;;
		*) unset reply; return 1;;
	esac
}



# Installation Functions #
check_for_root() {
	# Check if the user has root privilages
	if [ "${opts_root_cmd+x}" ] ; then
		[ "${opts_root_cmd}" = "none" ] && error "Unable to get root privilages" && return 1
		return 0
	elif [ "$(command -v sudo)" ] && notice "Checking for root with 'sudo'" && [ "$(sudo printf 't\n')" = "t" ]; then
		opts_root_cmd="sudo"
		return 0
	elif [ "$(command -v su)" ] && notice "Checking for root with 'su'" && [ "$(su -c 'printf \"t\n\"')" = "t" ]; then
		opts_root_cmd="su"
		return 0
	else
		error "'sudo' and 'su' isn't installed. One is required for root privilages."
		opts_root_cmd="none"
		return 1
	fi
}


run_as_root() {
	# Run the command, ${1}, as root
	case "${opts_root_cmd}" in
		"sudo") eval "sudo ${SHELL} -c '$@'" ;;
		"su") eval "su -c '$@'" ;;
	esac
}


install_dotfiles() {
	# Install and/or sync dotfiles
	dotfile_dir="${HOME}/.local/dots"
	dotfile_url="https://github.com/Smeueg/Dotfiles.git"

	dot_clone() {
		# Clone as bare repo
		notice 'Cloning bare repository'
		if ! git clone --bare "${dotfile_url}" "${dotfile_dir}"; then
			error "Failed to run 'git clone --bare ${dotfile_url} ${dotfile_dir}'"
			return 1
		fi
		# Do not show untracked files
		notice 'Configuring repo to not show untracked files'
		if ! git --git-dir="${dotfile_dir}" config status.showUntrackedFiles no; then
			warning "Failed to run 'git --git-dir=${dotfile_dir} config status.showUntrackedFiles no'"
			return 1
		fi
	}

	dot_sync() {
		# Backup files that are different from the git repo
		notice 'Backing up existing files'
		while read -r file; do
			file="${file#*$(printf '\t')}"
			dir="${HOME}/DotBackup/${file%/*}"
			file="${HOME}/${file}"

			if ! [ -d "${dir}" ] && ! mkdir --parents --verbose "${dir}"; then
				error "Failed to create directory '${dir}'\n"
				return 1
			fi
			mv --verbose "${file}" "${dir}"
		done <<-EOF
		$(git --git-dir=${dotfile_dir} --work-tree=$HOME diff --name-status)
		EOF
		unset file
		unset dir

		# Sync bare repo
		notice 'Syncing dotfiles'
		if ! git --git-dir="${dotfile_dir}" --work-tree="${HOME}" checkout; then
			error "Failed to run 'git --git-dir=${dotfile_dir} --work-tree=${HOME}'"
			return 1
		fi
	}

	if ! [ "$(git --git-dir=${dotfile_dir} rev-parse 2>&1)" ]; then
		if ! confirm "'${dotfile_dir}' is already a git repo, overwrite?"; then
			notice "Will not overwrite ${dotfile_dir}"
			if confirm "Resync dotfiles?"; then
				dot_sync
			else
				notice "Will not resync dotfiles"
			fi
			return
		fi
	fi
	dot_clone
	dot_sync

	unset -f dot_clone dot_sync
	unset dotfile_dir dotfile_url
}


install_font() {
	# Function to install fonts (JetBrains Nerd Font Mono)
	font_dir="${HOME}/.local/share/fonts"
	font_dir="${font_dir%/}/JetBrainsMono Nerd Font"

	# Create directory if doesn't exist and return if failed to create directory
	[ -d "${font_dir}" ] || { mkdir -pv "${font_dir}" || return; }

	url="https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono/Ligatures"
	for line in $(fetch "${url}" -); do
		[ "${line}" ] || continue
		[ "${line##*/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono/Ligatures/*}" ] && continue
		type="${line%\"*}"
		type="${type##*/}"
		url="https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono/Ligatures/${type}/complete"
		for line in $(fetch "${url}" -); do
			[ "${line}" ] || continue
			[ "${line##*Complete*Mono.ttf*}" ] && continue
			line="${line#*href=\"}"
			line="${line%\"*}"
			fetch "https://github.com${line%/blob/*}/raw/${line#*/blob/}" "${font_dir%/}/JetBrainsMono Nerd Font ${type} Complete.ttf"
		done
	done
	unset line type url font_dir
}


install_wallpaper() {
	# Downloads the wallpaper
	wallpaper_dir="${HOME}/.config/rice"
	url="https://i.imgur.com/DVJsvfN.png"
	[ -d "${wallpaper_dir}" ] || { mkdir -pv "${wallpaper_dir}" || return; }

	fetch "${url}" "${wallpaper_dir}/Shark Space.png"
	fetch "https://free4kwallpapers.com/uploads/originals/2021/05/25/meteor-shower-wallpaper.png" "${wallpaper_dir}/Meteor Shower.png"
	unset url wallpaper_dir
}


install_nix() {
	# Installes the nix package manager
	if [ "$(command -v nix)" ]; then
		notice "Nix is already installed ('nix' is a command), exiting"
		return
	elif [ -d "/nix" ]; then
		notice "Nix is already installed ('/nix' is a directory), exiting"
		return
	fi

	if ! check_for_root; then
		notice "Installing nix requires root privilages, exiting"
		return
	fi

	install_nix_multi_user() {
		notice "Installing nix in multi-user mode"
		sh -s -- --daemon <<-EOF
		$(fetch "https://nixos.org/nix/install" -)
		EOF
	}

	install_nix_single_user() {
		notice "Installing nix in multi-user mode"
		sh -s -- --no-daemon <<-EOF
		$(fetch "https://nixos.org/nix/install" -)
		EOF
	}

	if [ "${opts_root_cmd}" = "sudo" ]; then
		if confirm "'sudo' exists, install nix in multi-user mode?"; then
			install_nix_multi_user
		elif confirm "Install nix in single-user mode?"; then
			install_nix_single_user
		fi
	elif confirm "'sudo' doesn't exist, install nix in single-user mode?"; then
		install_nix_single_user
	else
		notice "Won't install nix, exiting"
	fi

	unset -f install_nix_multi_user install_nix_single_user
}


install_SU() {
	check_for_root
	fetch "https://github.com/terminalforlife/Extra/raw/master/source/simplify-ubuntu/simplify-ubuntu-installer" "/tmp/SU-installer"
	if ! [ -f "/tmp/SU-installer" ]; then
		error "Failed to download ubuchk-installer"
		return
	fi
	run_as_root "sh /tmp/ubuchk-installer"
}


install_ubuchk() {
	check_for_root
	fetch "https://raw.githubusercontent.com/terminalforlife/PerlProjects/master/source/ubuchk/ubuchk-installer" "/tmp/ubuchk-installer"
	if ! [ -f "/tmp/ubuchk-installer" ]; then
		error "Failed to download ubuchk-installer"
		return
	fi
	run_as_root "sh /tmp/ubuchk-installer"
}


install_droidcam() {
	# Installs droidcam
	if [ "$(command -v droidcam)" ]; then
		if ! confirm "Droidcam is already installed (The command 'droidcam-cli' exists), do you wan't to recompile and reinstall?"; then
			notice "Won't reinstall droidcam"
			return
		fi
	fi

	if ! [ -d /lib/modules/$(uname -r)/build ]; then
		error "Kernel headers not found: Kernel $(uname -r)"
		return
	fi

	check_for_root
	if ! [ -f "/tmp/droidcam_latest.zip" ]; then
		fetch "https://files.dev47apps.net/linux/droidcam_1.8.2.zip" "/tmp/droidcam_latest.zip"
		if ! [ -f "/tmp/droidcam_latest.zip" ]; then
			error "Failed to download droidcam zip file."
			return
		fi
	fi

	unzip /tmp/droidcam_latest.zip -d /tmp/droidcam
	run_as_root "cd /tmp/droidcam; ./install-client; ./install-sound; ./install-video"
}


mktmpfs() {
	if ! [ -f "/etc/fstab" ]; then
		error "/etc/fstab doesn't exist"
		return
	fi

	warning "This will mount tmpfs with a size of 512M to /etc/fstab"
	while IFS= read -r line; do
		[ "${line%%tmpfs*/tmp*tmpfs*}" ] && continue
		notice "Seems like '/tmp' is already mounted as tmpfs, "
		break
	done < /etc/fstab

	if ! confirm "Do you want to continue?"; then
		notice "Won't add tmpfs to /etc/fstab"
		return
	fi
	check_for_root
	notice "Adding tmpfs to '/etc/fstab'"
	run_as_root 'printf "tmpfs   /tmp         tmpfs   rw,nodev,nosuid,size=512M          0  0\n" >>/etc/fstab'
}


mkswapfile() {
	warning "This will create a swapfile of 4Gb"
	check_for_root
	run_as_root 'dd if=/dev/zero of=/swapfile bs=1M count=4096 status=progress; chmod 600 /swapfile; /sbin/mkswap /swapfile; /sbin/swapon /swapfile; printf "/swapfile none swap defaults 0 0\n" >> /etc/fstab'
}


apt_enable_brave() {
	check_for_root
	cmd=""
	tmp=$(dpkg -l apt-transport-https 2>&1)
	if [ "${tmp##*no packages found*}" ]; then
		cmd="apt install apt-transport-https;"
	fi
	unset tmp

	if [ "$(command -v curl)" ]; then
		cmd="${cmd}curl -fsSLo /usr/share/keyrings/brave-browser-archive-keyring.gpg https://brave-browser-apt-release.s3.brave.com/brave-browser-archive-keyring.gpg"
	elif [ "$(command -v wget)" ]; then
		cmd="${cmd}wget --no-hsts https://brave-browser-apt-release.s3.brave.com/brave-browser-archive-keyring.gpg -O /usr/share/keyrings/brave-browser-archive-keyring.gpg"
	fi

	cmd="${cmd}; printf 'deb [signed-by=/usr/share/keyrings/brave-browser-archive-keyring.gpg arch=amd64] https://brave-browser-apt-release.s3.brave.com/ stable main\n' > /etc/apt/sources.list.d/brave-browser-release.list"
	run_as_root "${cmd}"
	unset cmd
}


apt_bootstrap_packages() {
	packages="emacs awesome rofi"

	printf 'This will install:\n - Emacs\n - AwesomeWM\n - Rofi\n'
	if ! confirm "Are you sure?"; then
		notice "Won't install packages"
		return
	fi

	check_for_root
	run_as_root "apt install emacs awesome rofi"
}



# UI Functions #
opts_setup() {
	opts_tab_count=0
	# Setup the options to determine whether the dependencies are met
	_handle_or() {
		for opt_dep in $1; do
			[ "$(command -v ${opt_dep})" ] || continue
			opt_has_deps=:
		done
	}

	_handle_comma() {
		for opt_dep in $1; do
			if ! [ "${opt_dep##*\|*}" ]; then
				IFS="|" _handle_or "${opt_dep}"
			elif ! [ "$(command -v ${opt_dep})" ]; then
				opt_has_deps=false
				return
			else
				opt_has_deps=:
			fi
		done
	}

	# Check if dependencies are met
	for opt in ${opts}; do
		if ! [ "${opt%%== * ==}" ]; then
			opt_tmp="${opt_tmp} Continue ${newline}${opt}${newline}"
			opts_tab_count=$((opts_tab_count + 1))
			continue
		fi
		opt_has_deps=false
		opt_deps="${opt#*\[}"
		opt_deps="${opt_deps%\]*}"
		IFS="," _handle_comma "${opt_deps}"

		opt_front_tmp="${opt%%\[*}"
		opt_front_tmp="${opt_front_tmp%${opt_front_tmp##*[! ]}}"
		opt_back_tmp="${opt##*\|}"
		opt_back_tmp="${opt_back_tmp# }"

		if ${opt_has_deps}; then
			opt_tmp="${opt_tmp} [ ] ${opt_front_tmp}"
		else
			opt_tmp="${opt_tmp}\033[31m [-] ${opt_front_tmp} [Dependencies: ${opt_deps}]"
		fi

		opt_tmp="${opt_tmp} \033[0m|${opt_back_tmp}${newline}"
	done
	opts="${opt_tmp} Continue "
	unset -f _handle_comma _handle_or
	unset opt_has_deps opt_dep opt_front_tmp opt_back_tmp
	get_cur_row
}


opts_print() {
	# Get Height and Width for the current tab
	opts_tmp_line=0
	opts_tmp_tab=0
	opts_tmp_width=52
	opts_tmp_header_width=0
	for opt in ${opts}; do
		if ! [ "${opt##== * ==}" ]; then
			opts_tmp_header_width=$((opts_tmp_header_width + ${#opt} - 2))
			opts_tmp_tab=$((opts_tmp_tab + 1))
			continue
		fi

		if [ ${opts_tmp_tab} -eq ${opts_chosen_tab} ]; then
			opts_tmp_line=$((opts_tmp_line + 1))
			opt="${opt%\\033*}"
			opt="${opt#*\\033[31m}"
			[ ${#opt} -gt ${opts_tmp_width} ] && opts_tmp_width=${#opt}
		fi
	done
	opts_height=${opts_tmp_line}

	if [ ${opts_tmp_header_width} -gt ${opts_tmp_width} ]; then
		opts_width=$((opts_tmp_header_width + 4))
	else
		opts_width=$((opts_tmp_width + 5))
	fi

	unset opts_tmp_line opts_tmp_tab opts_tmp_width opts_tmp_header_width
	# Actually Print
	opts_tmp_tab=0
	opts_tmp_line=0
	opts_tmp_header=""
	opts_tmp_str=""
	opts_tmp_line_str=$(printn "─" $((opts_width - 3)))

	printf "\r\033[J${opts_tmp_line_str}╮\n%${opts_width}s\r│\n" "│"
	for opt in ${opts}; do
		if ! [ "${opt%%== * ==}" ]; then
		opts_tmp_tab=$((opts_tmp_tab + 1))
		opts_tmp_line=0

		opt_tmp=${opt#== }
		opt_tmp=${opt_tmp% ==}
		if [ ${opts_tmp_tab} -eq ${opts_chosen_tab} ]; then
			opt_tmp="\033[7m\033[1m${opt_tmp}"
		fi
		opts_tmp_header="${opts_tmp_header} \033[31m${opt_tmp}\033[0m ─"
		continue
	fi

	opts_tmp_line=$((opts_tmp_line + 1))
	if [ ${opts_tmp_tab} -eq ${opts_chosen_tab} ]; then
		if [ ${opts_tmp_line} -eq ${opts_chosen_line} ]; then
			printf "%${opts_width}s\r│ \033[7m${opt%\|*}\n" "│"
		else
			printf "%${opts_width}s\r│ ${opt%\|*}\n" "│"
		fi
		fi
	done
	opts_tmp_header="\033[0m╭──${opts_tmp_header}"

	# footer
	printf "\
\033[${row};0H${opts_tmp_header}\033[${opts_height}B
\n%${opts_width}s\r│\n${opts_tmp_line_str}┤\
\r\033[0m├── \033[33mj/↓:Down\033[0m ─ \033[33mk/↑:Up\033[0m ─ \033[33mq:quit\033[0m ─ \033[33mEnter/Space:Select\033[0m ─
${opts_tmp_line_str}╯\r╰── \033[33mh/←:Select Left Tab\033[0m ─ \033[33ml/→:Select Right Tab\033[0m \n
" "│"
	unset opts_tmp_tab opts_tmp_line opt_tmp
}

opts_select() {
	opts_tmp_tab=0
	opts_tmp_line=0
	opts_tmp=""
	for opt in ${opts}; do
		if ! [ "${opt%%== * ==}" ]; then
			opts_tmp_tab=$((opts_tmp_tab + 1))
			opts_tmp_line=0
			opts_tmp="${opts_tmp}${opt}${newline}"
			continue
		fi

		opts_tmp_line=$((opts_tmp_line + 1))
		if [ ${opts_tmp_line} -eq ${opts_chosen_line} ] && [ ${opts_tmp_tab} -eq ${opts_chosen_tab} ]; then
			if ! [ "${opt%% Continue }" ]; then
				opts_loop=false
			elif ! [ "${opt%% \[X\]*}" ]; then
				opts_tmp="${opts_tmp} [ ]${opt# \[X\]}${newline}"
			elif ! [ "${opt%% \[ \]*}" ]; then
				opts_tmp="${opts_tmp} [X]${opt# \[ \]}${newline}"
			else
				opts_tmp="${opts_tmp}${opt}${newline}"
			fi
		else
			opts_tmp="${opts_tmp}${opt}${newline}"
		fi
	done
	opts="${opts_tmp}"
	[ ${opts_chosen_line} -ne ${opts_height} ] && opts_chosen_line=$((opts_chosen_line + 1))
	unset opts_tmp_tab opts_tmp_line opts_tmp
}

opts_handle_keypress() {
	if [ "${stty_settings+x}" ]; then
		stty -icanon
		trap "stty '${stty_settings}'; exit 1" INT
	fi

	opts_loop=:
	while ${opts_loop}; do
		read_char

		if [ "${opts_input}" = "$(printf '\033')" ]; then
		 	read_char
		 	read_char
		 	case "${opts_input}" in
		 		"A") opts_input="k";;
		 		"B") opts_input="j";;
		 		"C") opts_input="l";;
		 		"D") opts_input="h";;
		 	esac
		fi

		case "${opts_input}" in
		 	"h") [ ${opts_chosen_tab} -ne 1 ] && opts_chosen_tab=$((opts_chosen_tab - 1)); opts_chosen_line=1;;
		 	"k") [ ${opts_chosen_line} -ne 1 ] && opts_chosen_line=$((opts_chosen_line - 1));;
		 	"j") [ ${opts_chosen_line} -ne ${opts_height} ] && opts_chosen_line=$((opts_chosen_line + 1));;
		 	"l") [ ${opts_chosen_tab} -ne ${opts_tab_count} ] && opts_chosen_tab=$((opts_chosen_tab + 1)); opts_chosen_line=1;;
			"q") opts_loop=false; unset opts ;;
			" "|${newline}||"") IFS=${newline} opts_select;;
		esac
		printf "\033[${row};0H"
		IFS=${newline} opts_print
	done
	printf "\033[${row};0H\033[J"
	unset opts_loop
	if [ "${stty_settings+x}" ]; then
		stty "${stty_settings}"
	fi
}

opts_run() {
	for opt in ${opts}; do
		[ "${opt%% \[X\]*}" ] && continue
		printf '\n'
		i=0
		while [ ${i} -ne ${COLUMNS} ]; do
			printf '━'
			i=$((i + 1))
		done
		opt_tmp_str="${opt# \[?\] }"
		opt_tmp_str="${opt_tmp_str% \\033*}"
		printf "\r\033[$(((COLUMNS - ${#opt_tmp_str}) / 2))C %s \n" "${opt_tmp_str}"
		unset i opt_tmp_str
		${opt##*\|}
	done
}


special=$(printf '\033')
newline="
"


notice "If the terminal acts weird, then please run 'stty icanon'"
IFS=${newline} opts_setup
IFS=${newline} opts_print
opts_handle_keypress


[ "${opts+x}" ] || exit 0
IFS=${newline} opts_run
