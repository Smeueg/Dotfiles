#!/bin/ksh
# ------------------------------------------------
# Script Name    - smeueger-new
# Author Name    - Smeueg
# Author Email   - Smeueg@gmail.com
# Author Gitlab  - https://gitlab.com/Smeueg
# Last Updated   - Fri  8 Apr 14:19:34 WIB 2022
# ------------------------------------------------
# A newer version of 'smeueger' which aims to be more verbose,
# clear, fancy, and of course, more smeueg.


## Variables ##
WALLPAPER_DIR="${HOME}/.config/rice/"
WALLPAPER_URL="https://i.imgur.com/DVJsvfN.png"
DOTFILE_DIR="${HOME}/.local/dots"
DOTFILE_URL="https://gitlab.com/smeueg/dotfiles.git"
FONT_DIR="${HOME}/.local/share/fonts/"

newline="
"
line_chosen=5
opts="\
Dotfiles              [git,mv]                          | install_dotfiles
Font (JetBrainsMono)  [wget|curl]                       | install_font
Wallpaper             [wget|curl]                       | install_wallpaper
Nix Package Manager   [wget|curl]                       | install_nix
TFL's Simplify Ubuntu [wgt|crl]                       | install_SU
Droidcam              [sudo|su,wget|curl,unzip,cc,make] | install_droidcam
Mount tmpfs to /tmp   [sudo|su]                         | mktmpfs
Create Swapfile       [sudo|su,mkswap,swapon,dd,chmod]  | mkswapfile"


## Utility Functions ##
error() { printf '\033[1m\033[31m[ERROR]\033[0m %s\n' "${1}"; }
warning() { printf '\033[1m\033[33m[ERROR]\033[0m %s\n' "${1}"; }
notice() { printf '\033[1m\033[32m[NOTICE]\033[0m %s\n' "${1}"; }

if [ "${BASH_VERSION}" ] || [ "${KSH_VERSION}" ]; then
	read_char() { IFS= read -n 1 input; }
elif [ "${ZSH_NAME}" ]; then
	emulate sh
	read_char() { IFS= read -k 1 input; }
else
	if ! [ "$(command -v stty)" ]; then
		error "Command 'stty' not found."
		exit
	fi

	stty_settings=$(stty -g)
	read_char() {
		input="$(dd bs=1 count=1 2>&1)"
		input="${input%${input#?}}"
	}

	get_cur_row() {
		stty -icanon
		printf '\033[6n'
		while :; do
			read_char
			[ "${input}" = "R" ] && break
			row="${row}${input}"
		done
		row="${row#*\[}"
		row="${row%;*}"
		stty "${stty_settings}"
	}
fi


if [ "${BASH_VERSION}" ] || [ "${KSH_VERSION}" ] || [ "${ZSH_NAME}" ]; then
	get_cur_row() {
		# Get Cursor Row
		printf '\033[6n'
		read -sdR row
		row=${row#*\[}
		row=${row%;*}
		printf '\r\033[2K%s\n' "${row}"
	}
fi


replace() {
	# Replace ${IFS} in ${2} with ${1}
	for chars in ${2}; do
		tmp="${tmp}${chars}${1}"
	done
	tmp="${tmp%${1}}"
	printf '%s\n' "${tmp}"
	unset tmp
}


## "Main" Functions ##
opts_setup() {
	# Setup the options to determine whether the dependencies are met
	_handle_or() {
		for dep in $1; do
			[ "$(command -v ${dep})" ] || continue
			has_deps=:
		done
	}

	_handle_comma() {
		for dep in $1; do
			if ! [ "${dep##*\|*}" ]; then
				IFS="|" _handle_or "${dep}"
			elif ! [ "$(command -v ${dep})" ]; then
				has_deps=false
				return
			else
				has_deps=:
			fi
		done
	}

	for opt in ${opts}; do
		has_deps=false
		deps=""
		deps="${opt#*\[}"
		deps="${deps%\]*}"
		IFS="," _handle_comma "${deps}"

		if ${has_deps}; then
			opt_tmp="${opt_tmp} [ ] ${opt}${newline}"
		else
			opt_tmp="${opt_tmp}\033[31m [-] ${opt}  [Dependencies: ${deps}] ${newline}"
		fi
	done
	opts="${opt_tmp%?}"
	unset -f _handle_comma _handle_or
	unset deps dep has_deps opt opt_tmp
}

opts_get_len() {
	# Get maximum text length from options
	min_len=53
	for line in ${opts}; do
		front="${line% \| *}"
		front="${front%\[*}"
		front="${front%${front##*[! ]}} "
		highlight=""
		back=""
		if ! [ "${line%%*\[-\]*}" ]; then
			back="  [${line##*\[}"
			front="${front#????????}"
		fi

		len_tmp=$((${#front} + ${#back}))
		[ ${len_tmp} -gt ${len:-0} ] && len=${len_tmp}
	done


	[ ${min_len} -gt ${len} ] && len=${min_len}
	len=$((len + 2)) # Take into account the box padding
	unset len_tmp min_len

	if [ ${COLUMNS} -lt ${len} ]; then
		error "Insufficient terminal size. Terminal columns: ${COLUMNS}, Required columns: ${len}"
		exit 1
	fi
}

opts_print() {
	# Print the options
	[ ${len+x} ] || IFS=${newline} opts_get_len
	idx=0
	for line in ${opts}; do
		front="${line% \| *}"
		front="${front%\[*}"
		front="${front%${front##*[! ]}} "
		highlight=""
		back=""
		[ "${line%%*\[-\]*}" ] || back="  [${line##*\[}"
		[ ${idx} -eq ${line_chosen} ] && highlight=" \033[7m"

		printf "\033[2K\r%$((len + 3))s\r" "│"
		printf "│ %b \033[0m\n" "${highlight}${front% }${back% }"
		idx=$((idx + 1))
	done
	unset idx
}


get_cur_row() {
	# Get column position
	stty_settings=$(stty -g)
	stty -icanon -echo
	printf "\033[6n"
	while :; do
		read_char
		[ "${input}" = "R" ] && break
		row="${row}${input}"
	done
	row="${row#*\[}"
	row="${row%;*}"
	stty "${stty_settings}"
}


header_print() {
	[ ${len+x} ] || IFS=${newline} opts_get_len
	while [ ${i:-0} -lt ${len} ]; do
		str="${str}─"
		i=$((i + 1))
	done
	if [ "${1}" = "header" ]; then
		printf '%s╮\r' "${str}"
		printf '╭── \033[31mSmeueger\033[0m \n'
		printf "%$((len + 3))s\r│\n" "│"
	elif [ "${1}" = "footer" ]; then
		printf "%$((len + 3))s\r│\n" "│"
		printf '%s╯\r' "${str}"
		printf '╰── \033[33mj/↓:Down\033[0m ─ \033[33mk/↑:Up\033[0m ─ \033[33mq:quit\033[0m ─ \033[33mEnter/Space:Select\033[0m \n'
	fi
	unset str i
}




IFS=${newline} opts_get_len
IFS=${newline} opts_setup
header_print "header"
#get_cur_row
IFS="${newline}" opts_print
header_print "footer"

exit
if [ "${stty_settings+x}" ]; then
	stty -icanon
	trap "stty ${stty_settings}; exit 1" INT TERM QUIT ALRM
fi

while read_char; do
	printf "\r\033[2K\033[${row};1H"
	IFS=${newline} opts_print
	printf "\033[2B"
done
