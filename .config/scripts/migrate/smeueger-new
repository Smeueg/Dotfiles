#!/bin/sh
# TODO: trap Ctrl-c to restore stty echo

# Variables
WALLPAPER_DIR="${HOME}/.config/rice/"
WALLPAPER_URL="https://i.imgur.com/DVJsvfN.png"
DOTFILE_DIR="${HOME}/.local/dots"
FONT_DIR="${HOME}/.local/share/fonts/"


# Character Variable
special="$(printf '\033')"
newline="$(printf '\n')"
choices="
Dotfiles              {git}        | install_dotfiles
Font (JetBrainsMono)  {wget||curl} | install_font
Wallpaper             {wget||curl} | install_wallpaper
Nix Package Manager   {wget||curl} | install_nix
TFL's Simplify Ubuntu {wget||curl} | install_SU
"

# Utility functions
# Use /dev/null if possible, else use a subshell
error() { printf "\033[31mERROR: ${1}\033[0m\n" >&2; }
warning() { printf "\033[33mWARNING: ${1}\033[0m\n" >&2; }


# Check if /dev/null exists, if it does use that, else use a subshell
# To capture stdout
if [ -c /dev/null ] && [ -w /dev/null ]; then
	check_depend() { command -v "${1}" >/dev/null; }
else
	check_depend() { [ "$(command -v >/dev/null)" ]; }
fi


# Check for curl or wget
if check_depend curl; then
	fetch() { curl -L "${1}" -o "${2}"; }
elif check_depend wget; then
	fetch() { wget "${1}" -O "${2}"; }
fi


# Read a single character some shells, including bash and zsh, has read -n1
# which is better to use than dd. So use that if it's available
if [ "${BASH_VERSION}" ]; then
	read_char() { IFS= read -n 1 input; }
else
	read_char() {
		stty -icanon
		input="$(dd bs=1 count=1 2>/dev/null)"
		stty icanon
	}
fi


# Prompt user with Y or no question, with ${1} as the prompt
# Usage: `confirm "Are you sure?"` -> "Are you sure? [Y\n] "
confirm() {
	printf '%s [Y\\n] ' "${1}"
	read reply
	case "${reply}" in
		[Yy][Ee][Ss]|[Yy]|"") return 0 ;;
		*) return 1;;
	esac
}


# Replace $1 with $2 in $3
# Usage: `replace "foo" "bar" "foo jar bar"` â”€> "bar jar bar"
replace() {
	str="${3}"
	while ! [ "${str##*${1}*}" ]; do
		str="${str%%${1}*}${2}${str#*${1}}"
	done
	printf '%s\n' "${str}"
	unset str
}


# Pick a choice interactively with ${1} being the string
# Usage: `mini_choice "$(printf 'foo\nbar\nbaz')"`
mini_choice() {
	chosen=0
	while true; do
		i=0
		while read line; do
			if [ ${i} -eq ${chosen%%:*} ]; then
				printf '\033[7m %s \033[0m\n' "${line}"
				chosen_line="${line}"
			else
				printf ' %s \n' "${line}"
			fi
			i=$((i+1))
		done <<-EOF
		${1}
EOF

		stty -echo
		read_char
		if [ "${input}" = "${special}" ]; then
			read_char
			read_char
			case "${input}" in
				"A") input="k" ;;
				"B") input="j" ;;
			esac
		fi
		stty echo

		case "${input}" in
			"k") [ ${chosen} -eq 0 ] || chosen=$((chosen-1));;
			"j") [ ${chosen} -eq $((i-1)) ] || chosen=$((chosen+1));;
			"q")
				choice_out=""
				return ;;
			"${newline}"|" ")
				printf "\033[${i}A\033[J"
				choice_out="${chosen_line}"
				unset chosen_line chosen input i
				return ;;
		esac
		printf "\033[${i}A\033[J"
	done
}



# Installation functions

dot_sync() {
	# Backup files that are different from the git repo
	printf 'Backing up existing files...\n'
	while read file; do
		file="${file#*$(printf '\t')}"
		dir="${HOME}/DotBackup/${file%/*}"
		file="${HOME}/${file}"

		if ! [ -d "${dir}" ] && ! mkdir --parents --verbose "${dir}"; then
			error "Failed to create directory '${dir}'\n"
			return
		fi
		mv --verbose "${file}" "${dir}"
	done <<-EOF
$(git --git-dir=${DOTFILE_DIR} --work-tree=$HOME diff --name-status)
EOF
	# Sync bare repo
	printf 'Syncing dotfiles...\n'
	if ! git --git-dir="${DOTFILE_DIR}" --work-tree="${HOME}" checkout; then
		error "Failed to run 'git --git-dir=${DOTFILE_DIR} --work-tree=${HOME}'"
		return
	fi
}

dot_clone() {
	# Clone as bare repo
	printf 'Cloning bare repo...\n'
	if ! git clone --bare "${DOTFILE_URL}" "${DOTFILE_DIR}"; then
		error "Failed to run 'git clone --bare ${DOTFILE_URL} ${DOTFILE_DIR}'"
		return
	fi
	# Do not show untracked files
	printf 'Configuring repo to not show untracked files...\n'
	if ! git --git-dir="${DOTFILE_DIR}" config status.showUntrackedFiles no; then
		warning "Failed to run 'git --git-dir=${DOTFILE_DIR} config status.showUntrackedFiles no'"
		return
	fi
}

install_dotfiles() {
	printf 'Installing Dotfiles...\n'
	if ! [ "$(git --git-dir=${DOTFILE_DIR} rev-parse 2>&1)" ]; then
		printf '%s is already a git repo, overwrite?\n' "${DOTFILE_DIR}"
		mini_choice "$(printf 'Overwrite and Sync\nSync\nCancel')"
		case "${choice_out}" in
			"Overwrite and Sync")
				dot_clone
				dot_sync
				;;
			"Sync")
				dot_sync
				;;
			*)
				printf "Won't do anything...\n"
				;;
		esac
		return
	fi
	dot_clone
	dot_sync
}


install_nix() {
	# Check if nix is already installed
	if check_depend nix; then
		printf 'Nix seems to already be installed (command nix found), exiting...\n'
		return
	elif [ -d /nix ]; then
		printf 'Nix seems to already be installed (`/nix` exists), exiting...\n'
		return
	fi

	# Prompt for confirmation on installing in single-user mode
	if confirm "WARNING: This will install nix in single-user mode, continue?"; then
		printf 'Continuing nix installation...\n'
	else
		printf 'Not running nix installation...\n'
		return
	fi

	su -c "mkdir -m 0755 /nix && chown ${USER} /nix"
	[ -d /nix ] || return

	sh -s -- --no-daemon <<-EOF
	$(curl -L https://nixos.org/nix/install)
EOF
}


install_font() {
	# Will install JetBrainsMono
	# Create directory FONT_DIR if needed
	FONT_DIR="${FONT_DIR%/}/JetBrainsMono"
	[ -d "${FONT_DIR}" ] ||
		mkdir --parents --verbose "${FONT_DIR}" || return

	# Get every JetBrainsMono font
	while read line; do
		! [ "${line}" ] || [ "${line##*/JetBrains/JetBrainsMono/blob/master*}" ] && continue
		line="https://github.com${line#*href=\"}"
		line="${line%\"*}"
		line=$(replace "blob" "raw" "${line}")
		#fetch "${line}" "${FONT_DIR}/${line##*/}"
		printf '%s\n' "${FONT_DIR}/${line##*/}"
	done <<EOF
$(curl -L https://github.com/JetBrains/JetBrainsMono/tree/master/fonts/otf)
EOF
}


install_wallpaper() {
	printf 'Getting wallpaper...\n'
	fetch "${WALLPAPER_URL}" "${WALLPAPER_DIR%/}/Shark Space.png"
}

install_SU() {
	sh <<EOF
$(curl -L "https://github.com/terminalforlife/Extra/raw/master/source/simplify-ubuntu/simplify-ubuntu-installer")
EOF
}


# MAIN SELECTION #
# Check Dependencies and warn that some dependencies aren't met
while read line; do
	[ "${line}" ] || continue
	deps="${line#*\{}"
	deps="${deps%\}*}"
	deps_satisfied=false

	# Check for dependencies (|| is or)
	for dep in $(replace "||" " " "${deps}"); do
		check_depend "${dep}" || continue
		deps_satisfied=true
		break
	done

	# Format Choices
	[ "${tmp}" ] && tmp="${tmp}\n"
	if ${deps_satisfied}; then
		tmp="${tmp}[ ] ${line}"
	else
		tmp="${tmp}[-] ${line}"
		line="${line%%\{*}"
		line="${line%${line##*[! ]}} "
		warning "${line} will not be an option, as dependencies aren't met: ($(replace "||" " or " "${deps}"))"
	fi
done <<EOF
${choices}
EOF

choices=$(printf "${tmp}\nContinue\n")
unset tmp


chosen=0
trap 'stty echo; exit 1' INT
stty -echo
while true; do
	i=0
	printf '\033[s'
	while read line; do
		line="${line%%\{*}"
		line="${line%${line##*[! ]}} "


		if [ ${i} -eq ${chosen} ]; then
			printf '\033[7m %s\033[0m\n' "${line}"
		else
			printf ' %s\n' "${line}"
		fi
		i=$((i+1))
	done <<EOF
${choices}
EOF

	read_char
	if [ "${input}" = "${special}" ]; then
		read_char
		read_char
		case "${input}" in
			"A") input="k" ;;
			"B") input="j" ;;
		esac
	fi


	case "${input}" in
		"k") [ ${chosen} -ne 0 ] && chosen=$((chosen-1));;
		"j") [ ${chosen} -ne $((i-1)) ] && chosen=$((chosen+1));;
		"q")
			choice_out=""
			return ;;
		"${newline}"|" ")
			if [ ${chosen} -eq $((i-1)) ]; then
				printf "\033[${i}A\033[J"
				break
			else
				choices="$(
				i=0
				while read line; do
					if [ "${i}" = "${chosen}" ]; then
						if [ "${line}" = "Continue" ]; then
							printf '%s\n' " Continue "
						elif [ "${line%${line#??}}" = "[X" ]; then
							printf '%s\n' "[ ${line#\[?}"
						elif [ "${line%${line#??}}" = "[ " ]; then
							printf '%s\n' "[X${line#\[?}"
						else
							printf '%s\n' "[-${line#\[?}"
						fi
					else
						printf '%s\n' "${line}"
					fi
				i=$((i+1))
				done <<EOF
${choices}
EOF
)"
			fi
			;;
	esac
	printf "\033[${i}A\033[J"
done
stty echo

while read line; do
	[ "${line%%\[X*}" ] && continue
	# !! Replace echo with eval once ready !!
	echo "${line#*| }"
done <<EOF
${choices}
EOF
