#!/bin/sh
# ------------------------------------------------
# Script Name    - smeueger
# Author Name    - Smeueg
# Author Email   - Smeueg@gmail.com
# Author Gitlab  - https://gitlab.com/Smeueg
# Last Updated   - Sat 11 Jun 2022
# ------------------------------------------------
# Script to become more smeueg instantly

# Variables #
opts="\
== Rice ==
Dotfiles              [git,mv]     | install_dotfiles
Font (JetBrainsMono)  [wget|curl]  | install_font
Wallpaper             [wget|curl]  | install_wallpaper
== System Config ==
Droidcam              [sudo|su,wget|curl,unzip,cc,make,uname] | install_droidcam
Nix Package Manager   [wget|curl]                             | install_nix
Mount tmpfs to /tmp   [sudo|su]                               | mktmpfs
Create Swapfile       [sudo|su,mkswap,swapon,dd,chmod]        | mkswapfile
"
opts_chosen_line=1
opts_chosen_tab=1

newline="
"

[ -d "/sbin" ] && PATH="${PATH}:/sbin"

# If apt exists, add extra apt specific options
if [ "$(command -v apt)" ]; then
	opts="${opts}${newline}== Debian/Ubuntu ==${newline}"
	opts="${opts}TFL's Ubuchk         [wget|curl]              | install_ubuchk"
	opts="${opts}Enable Brave Browser [sudo|su,wget|curl,dpkg] | apt_enable_brave${newline}"
	opts="${opts}Enable Github Cli    [sudo|su,wget|curl,dpkg] | apt_enable_gh_cli${newline}"
	opts="${opts}Bootstrap Packages   [sudo|su]                | apt_bootstrap_packages${newline}"
fi



# Utility Functions #
error() { printf '[\033[1;31mERROR\033[0m] %s\n' "${1}" >&2; }
warning() { printf '[\033[1;33mWARNING\033[0m] %s\n' "${1}"; }
notice() { printf '[\033[1;32mNOTICE\033[0m] %s\n' "${1}"; }

if [ "${BASH_VERSION}" ] || [ "${KSH_VERSION}" ]; then
	read_char() { IFS= read -n 1 opts_input; }
elif [ "${ZSH_NAME}" ]; then
	emulate sh
	read_char() { IFS= read -k 1 opts_input; }
else
	stty_settings=$(stty -g)
	read_char() {
		opts_input=$(dd bs=1 count=1 2>&1)
		opts_input=${opts_input%${opts_input#?}}
	}
fi

if [ "$(command -v curl)" ]; then
	fetch() { curl -L "${1}" -o "${2}"; }
elif [ "$(command -v wget)" ]; then
	fetch() { wget --no-hsts "${1}" -O "${2}"; }
fi


if ! [ "${COLUMNS+x}" ]; then
	get_cols() { COLUMNS=$(stty size); COLUMNS=${COLUMNS#* }; }
else
	get_cols() { :; }
fi


get_row() {
	# Get current cursor row
	[ "${stty_settings+x}" ] && stty -icanon
	printf '\033[6n'
	while :; do
		read_char
		[ "${opts_input}" = "R" ] && break
		row="${row}${opts_input}"
	done
	row=${row#*\[}
	row=${row%;*}
	[ "${stty_settings+x}" ] && stty "${stty_settings}"
	printf '\r\033[2K'
}

get_size() {
	size=$(stty size)
	term_h=${size% *}
	term_w=${size#* }
	unset size
}

printn() {
	# print ${1}, ${2} times
	i=0
	while [ ${i} -ne ${2} ]; do
		printf '%s' "${1}"
		i=$((i+1))
	done
	unset i
}

confirm() {
	# Prompt the user for a yes or no question, displaying ${1} as the question
	printf '%s [Y\\n] ' "${1}"
	read reply
	case ${reply} in
		[Yy][Ee][Ss]|[Yy]|"") unset reply; return 0;;
		*) unset reply; return 1;;
	esac
}



# Installation Functions #
check_for_root() {
	# Check if the user has root privilages
	if [ "${opts_root_cmd+x}" ] ; then
		[ "${opts_root_cmd}" = "none" ] && error "Unable to get root privilages" && return 1
		return 0
	elif [ "$(command -v sudo)" ] && notice "Checking for root with 'sudo'" && [ "$(sudo printf 't\n')" = "t" ]; then
		opts_root_cmd="sudo"
		return 0
	elif [ "$(command -v su)" ] && notice "Checking for root with 'su'" && [ "$(su -c 'printf \"t\n\"')" = "t" ]; then
		opts_root_cmd="su"
		return 0
	else
		error "'sudo' and 'su' isn't installed. One is required for root privilages."
		opts_root_cmd="none"
		return 1
	fi
}


run_as_root() {
	# Run the command, ${1}, as root
	case ${opts_root_cmd} in
		"sudo") eval "sudo ${SHELL} -c '$@'" ;;
		"su") eval "su -c '$@'" ;;
	esac
}


install_dotfiles() {
	# Install and/or sync dotfiles
	dotfile_dir="${HOME}/.local/dots"
	dotfile_url="https://github.com/Smeueg/Dotfiles.git"
	echo "${dotfile_dir}"
	[ -d "${dotfile_dir}" ] && echo "yes"

	dot_clone() {
		# Clone as bare repo
		notice 'Cloning bare repository'

		if [ -d "${dotfile_dir}" ]; then
			notice "Directory '${dotfile_dir}' exists, removing"
			if ! rm -rf "${dotfile_dir}"; then
				error "Failed to remove directory '${dotfile_dir}'"
				return 1
			fi
		fi

		if ! git clone --progress --bare "${dotfile_url}" "${dotfile_dir}"; then
			error "Command failed to run: git clone --bare \"${dotfile_url}\" \"${dotfile_dir}\""
			return 1
		fi

		# Do not show untracked files
		notice 'Configuring repo to not show untracked files'
		if ! git --git-dir="${dotfile_dir}" config status.showUntrackedFiles no; then
			warning "Failed to run 'git --git-dir=${dotfile_dir} config status.showUntrackedFiles no'"
			return 1
		fi
	}

	dot_sync() {
		# Backup files that are different from the git repo
		notice 'Backing up existing files'
		for file in $(git --git-dir="${dotfile_dir}" --work-tree="${HOME}" ls-tree --full-tree -r --name-only HEAD); do
			file="/${file}"
			dir="${HOME}/DotBackup${file%/*}"
			file="${HOME}${file}"
			if [ -f "${file}" ]; then
				if ! [ -d "${dir}" ]; then
					echo "${dir}"
					if ! mkdir -pv "${dir}"; then
						error "Failed to create directory '${dir}'"
						return 1
					fi
				fi

				if ! mv -v "${file}" "${dir}"; then
					error "Failed to move '${file}' to '${dir}'"
					return 1
				fi
			fi
		done
		unset file dir

		# Sync bare repo
		notice 'Syncing dotfiles'
		if ! git --git-dir="${dotfile_dir}" --work-tree="${HOME}" restore "${HOME}"; then
			error "Failed to run 'git --git-dir=${dotfile_dir} --work-tree=${HOME}' restore \"${HOME}\""
			return 1
		fi
	}

	if [ -d "${dotfile_dir}" ] && ! [ "$(git --git-dir="${dotfile_dir}" rev-parse 2>&1)" ]; then
		if ! confirm "Directory '${dotfile_dir}' is already a git repo, overwrite?"; then
			notice "Will not overwrite ${dotfile_dir}"
			if confirm "Resync dotfiles?"; then
				dot_sync || return 1
			else
				notice "Will not resync dotfiles"
			fi
			return
		fi
	fi
	dot_clone || return 1
	dot_sync || return 1

	unset -f dot_clone dot_sync
	unset dotfile_dir dotfile_url
}


install_font() {
	# Function to install fonts (JetBrains Nerd Font Mono)
	font_dir="${HOME}/.local/share/fonts"
	font_dir="${font_dir%/}/JetBrainsMono Nerd Font"

	# Create directory if doesn't exist and return if failed to create directory
	[ -d "${font_dir}" ] || { mkdir -pv "${font_dir}" || return; }

	notice "Downloading fonts"
	url="https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono/Ligatures"
	for line in $(fetch "${url}" -); do
		[ "${line}" ] || continue
		[ "${line##*/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono/Ligatures/*}" ] && continue
		type=${line%\"*}
		type=${type##*/}
		url="https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/JetBrainsMono/Ligatures/${type}/complete"
		for line in $(fetch "${url}" -); do
			[ "${line}" ] || continue
			[ "${line##*Complete*Mono.ttf*}" ] && continue
			line=${line#*href=\"}
			line=${line%\"*}
			fetch "https://github.com${line%/blob/*}/raw/${line#*/blob/}" "${font_dir%/}/JetBrainsMono Nerd Font ${type} Complete.ttf"
		done
	done
	unset line type url font_dir
}


install_wallpaper() {
	# Downloads the wallpaper
	wallpaper_dir="${HOME}/.config/rice"
	url="https://i.imgur.com/DVJsvfN.png"
	[ -d "${wallpaper_dir}" ] || { mkdir -pv "${wallpaper_dir}" || return; }

	notice "Downloading 'Shark Space.png'" && fetch "${url}" "${wallpaper_dir}/Shark Space.png"
	notice "Downloading 'Meteor Shower.png'" && fetch "https://free4kwallpapers.com/uploads/originals/2021/05/25/meteor-shower-wallpaper.png" "${wallpaper_dir}/Meteor Shower.png"
	unset url wallpaper_dir
}


install_nix() {
	# Installes the nix package manager
	if [ "$(command -v nix)" ]; then
		notice "Nix is already installed ('nix' is a command), exiting"
		return
	elif [ -d "/nix" ]; then
		notice "Nix is already installed ('/nix' is a directory), exiting"
		return
	fi

	if ! check_for_root; then
		notice "Installing nix requires root privilages, exiting"
		return
	fi

	install_nix_multi_user() {
		notice "Installing nix in multi-user mode"
		sh -s -- --daemon <<-EOF
		$(fetch "https://nixos.org/nix/install" -)
		EOF
	}

	install_nix_single_user() {
		notice "Installing nix in multi-user mode"
		sh -s -- --no-daemon <<-EOF
		$(fetch "https://nixos.org/nix/install" -)
		EOF
	}

	if [ "${opts_root_cmd}" = "sudo" ]; then
		if confirm "'sudo' exists, install nix in multi-user mode?"; then
			install_nix_multi_user
		elif confirm "Install nix in single-user mode?"; then
			install_nix_single_user
		fi
	elif confirm "'sudo' doesn't exist, install nix in single-user mode?"; then
		install_nix_single_user
	else
		notice "Won't install nix, exiting"
	fi

	unset -f install_nix_multi_user install_nix_single_user
}


install_SU() {
	check_for_root
	fetch "https://github.com/terminalforlife/Extra/raw/master/source/simplify-ubuntu/simplify-ubuntu-installer" "/tmp/SU-installer"
	if ! [ -f "/tmp/SU-installer" ]; then
		error "Failed to download ubuchk-installer"
		return
	fi
	run_as_root "sh /tmp/ubuchk-installer"
}


install_ubuchk() {
	check_for_root
	fetch "https://raw.githubusercontent.com/terminalforlife/PerlProjects/master/source/ubuchk/ubuchk-installer" "/tmp/ubuchk-installer"
	if ! [ -f "/tmp/ubuchk-installer" ]; then
		error "Failed to download ubuchk-installer"
		return
	fi
	run_as_root "sh /tmp/ubuchk-installer"
}


install_droidcam() {
	# Installs droidcam
	if [ "$(command -v droidcam)" ]; then
		if ! confirm "Droidcam is already installed (The command 'droidcam-cli' exists), do you wan't to recompile and reinstall?"; then
			notice "Won't reinstall droidcam"
			return
		fi
	fi

	if ! [ -d /lib/modules/$(uname -r)/build ]; then
		error "Kernel headers not found: Kernel $(uname -r)"
		return
	fi

	check_for_root
	if ! [ -f "/tmp/droidcam_latest.zip" ]; then
		fetch "https://files.dev47apps.net/linux/droidcam_1.8.2.zip" "/tmp/droidcam_latest.zip"
		if ! [ -f "/tmp/droidcam_latest.zip" ]; then
			error "Failed to download droidcam zip file."
			return
		fi
	fi

	unzip /tmp/droidcam_latest.zip -d /tmp/droidcam
	run_as_root "cd /tmp/droidcam; ./install-client; ./install-sound; ./install-video"
}


mktmpfs() {
	if ! [ -f "/etc/fstab" ]; then
		error "/etc/fstab doesn't exist"
		return
	fi

	warning "This will mount tmpfs with a size of 512M to /etc/fstab"
	while IFS= read -r line; do
		[ "${line%%tmpfs*/tmp*tmpfs*}" ] && continue
		notice "Seems like '/tmp' is already mounted as tmpfs, "
		break
	done < /etc/fstab

	if ! confirm "Do you want to continue?"; then
		notice "Won't add tmpfs to /etc/fstab"
		return
	fi
	check_for_root
	notice "Adding tmpfs to '/etc/fstab'"
	run_as_root 'printf "tmpfs   /tmp         tmpfs   rw,nodev,nosuid,size=512M          0  0\n" >>/etc/fstab'
}


mkswapfile() {
	warning "This will create a swapfile of 4Gb"
	check_for_root
	run_as_root 'dd if=/dev/zero of=/swapfile bs=1M count=4096 status=progress; chmod 600 /swapfile; /sbin/mkswap /swapfile; /sbin/swapon /swapfile; printf "/swapfile none swap defaults 0 0\n" >> /etc/fstab'
}


apt_enable_brave() {
	check_for_root
	cmd=""
	tmp=$(dpkg -l apt-transport-https 2>&1)
	if [ "${tmp##*no packages found*}" ]; then
		cmd="apt install apt-transport-https;"
	fi
	unset tmp

	if [ "$(command -v curl)" ]; then
		cmd="${cmd}curl -fsSLo /usr/share/keyrings/brave-browser-archive-keyring.gpg https://brave-browser-apt-release.s3.brave.com/brave-browser-archive-keyring.gpg"
	elif [ "$(command -v wget)" ]; then
		cmd="${cmd}wget --no-hsts https://brave-browser-apt-release.s3.brave.com/brave-browser-archive-keyring.gpg -O /usr/share/keyrings/brave-browser-archive-keyring.gpg"
	fi

	cmd="${cmd}; printf 'deb [signed-by=/usr/share/keyrings/brave-browser-archive-keyring.gpg arch=amd64] https://brave-browser-apt-release.s3.brave.com/ stable main\n' > /etc/apt/sources.list.d/brave-browser-release.list"
	run_as_root "${cmd}"
	unset cmd
}


apt_enable_gh_cli() {
	check_for_root
	cmd=""
	tmp=$(dpkg -l apt-transport-https 2>&1)
	if [ "${tmp##*no packages found*}" ]; then
		cmd="apt install apt-transport-https;"
	fi

	if [ "$(command -v curl)" ]; then
		cmd="${cmd}curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg -o /usr/share/keyrings/githubcli-archive-keyring.gpg"
	elif [ "$(command -v wget)" ]; then
		cmd="${cmd}wget --no-hsts https://cli.github.com/packages/githubcli-archive-keyring.gpg -O /usr/share/keyrings/githubcli-archive-keyring.gpg"
	fi

	cmd="${cmd}; printf 'deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main\n' > /etc/apt/sources.list.d/github-cli.list"
	run_as_root "${cmd}"
	unset cmd tmp
}


apt_bootstrap_packages() {
	packages="emacs awesome rofi sct"

	printf 'This will install:\n'
	for package in ${packages}; do
		printf ' - %s\n' "${package}"
		echo "${package}"
	done
	if ! confirm "Are you sure?"; then
		notice "Won't install packages"
		return
	fi

	check_for_root
	run_as_root "apt install emacs awesome rofi"
	unset package packages
}



# UI Functions #
opts_setup() {
	opts_tab_w=0 # Width needed to display tabs
	opts_w=0 # Width needed to display options + tabs
	opts_h=0 # Height needed to display options
	opts_tab_count=0
	opts_line_idx=0
	# Setup the options to determine whether the dependencies are met
	_handle_or() {
		for opt_dep in $1; do
			[ "$(command -v ${opt_dep})" ] || continue
			opt_has_deps=:
		done
	}

	_handle_comma() {
		for opt_dep in $1; do
			if ! [ "${opt_dep##*\|*}" ]; then
				IFS="|" _handle_or "${opt_dep}"
			elif ! [ "$(command -v ${opt_dep})" ]; then
				opt_has_deps=false
				return
			else
				opt_has_deps=:
			fi
		done
	}

	# Check if dependencies are met
	for opt in ${opts}; do
		if ! [ "${opt%%== * ==}" ]; then
			opts_tmp="${opts_tmp} Continue ${newline}${opt}${newline}"
			opts_tab_count=$((opts_tab_count + 1))
			opt=${opt#==}
			opt=${opt%==}
			opts_tab_w=$((opts_tab_w + ${#opt} + 1))
			[ ${opts_line_idx} -gt ${opts_h} ] && opts_h=${opts_line_idx}
			opts_line_idx=0
			continue
		fi
		opts_line_idx=$((opts_line_idx + 1))
		opt_has_deps=false
		opt_deps=${opt#*\[}
		opt_deps=${opt_deps%\]*}
		IFS="," _handle_comma "${opt_deps}"

		opt_front_tmp=${opt%%\[*}
		opt_front_tmp=${opt_front_tmp%${opt_front_tmp##*[! ]}}
		opt_back_tmp=${opt##*\|}
		opt_back_tmp=${opt_back_tmp# }

		if ${opt_has_deps}; then
			opts_tmp="${opts_tmp} [ ] ${opt_front_tmp}"
			[ $((${#opt_front_tmp} + 6)) -gt ${opts_w} ] &&
				opts_w=$((${#opt_front_tmp} + 6))
		else
			opts_tmp="${opts_tmp}\033[31m [-] ${opt_front_tmp} [Dependencies: ${opt_deps}]"
			[ $((${#opt_front_tmp} + ${#opt_deps} + 22)) -gt ${opts_w} ] &&
				opts_w=$((${#opt_front_tmp} + ${#opt_deps} + 22))
		fi

		opts_tmp="${opts_tmp} \033[0m|${opt_back_tmp}${newline}"
	done
	opts="${opts_tmp} Continue "

	[ ${opts_tab_w} -gt ${opts_w} ] && opts_w=${opts_tab_w}
	opts_h=$((opts_h + 3))
	opts_w=$((opts_w + 3))


	get_size
	get_row
	border_h=$(printn "─" $((opts_w - 1)))

	diff=$((term_h - row))
	if [ ${diff} -lt ${opts_h} ]; then
		i=0
		diff=$((opts_h - diff))
		while [ ${i} -ne ${diff} ]; do
			printf '\n'
			i=$((i + 1))
		done
		printf "\033[${opts_h}A"
		get_row
	fi
	unset -f _handle_comma _handle_or
	unset opt_has_deps opt_dep opt_front_tmp opt_back_tmp opts_line_idx
	unset opts_tab_w
}



opts_print() {
	idx_tab=0
	idx_line=0

	border_v=$(printf "%${opts_w}s\r%s" "│" "│")
	printf "\033[${row};H"
	for opt in ${opts}; do
		if ! [ "${opt##== * ==}" ]; then
			idx_tab=$((idx_tab + 1))
			opt=${opt#==}
			opt=${opt%==}
			[ ${idx_tab} -eq ${opts_chosen_tab} ] && opt="\033[7m${opt}"
			header="${header}─\033[1;31m${opt}\033[0m"
			continue
		fi

		[ ${idx_tab} -ne ${opts_chosen_tab} ] && continue
		idx_line=$((idx_line + 1))

		opt=${opt%\|*}
		[ ${idx_line} -eq ${opts_chosen_line} ] &&
			opt="\033[7m${opt}\033[0m"
		output="${output}\033[2K${border_v}${opt}${newline}"
	done
	opts_height=${idx_line}
	output="\033[2K${border_h}╮\r╭${header}${newline}${output}${border_h}╯\r╰${newline}"
	printf '%b\033[J' "${output}"
	unset output header idx_tab idx_line border_v
}



opts_select() {
	opts_tmp_tab=0
	opts_tmp_line=0
	opts_tmp=""
	for opt in ${opts}; do
		if ! [ "${opt%%== * ==}" ]; then
			opts_tmp_tab=$((opts_tmp_tab + 1))
			opts_tmp_line=0
			opts_tmp="${opts_tmp}${opt}${newline}"
			continue
		fi

		opts_tmp_line=$((opts_tmp_line + 1))
		if [ ${opts_tmp_line} -eq ${opts_chosen_line} ] && [ ${opts_tmp_tab} -eq ${opts_chosen_tab} ]; then
			if ! [ "${opt%% Continue }" ]; then
				opts_loop=false
			elif ! [ "${opt%% \[X\]*}" ]; then
				opts_tmp="${opts_tmp} [ ]${opt# \[X\]}${newline}"
			elif ! [ "${opt%% \[ \]*}" ]; then
				opts_tmp="${opts_tmp} [X]${opt# \[ \]}${newline}"
			else
				opts_tmp="${opts_tmp}${opt}${newline}"
			fi
		else
			opts_tmp="${opts_tmp}${opt}${newline}"
		fi
	done
	opts=${opts_tmp}
	opts_chosen_line=$((opts_chosen_line + 1))
	unset opts_tmp_tab opts_tmp_line opts_tmp
}


opts_handle_keypress() {
	if [ "${stty_settings+x}" ]; then
		stty -icanon
		trap "stty '${stty_settings}'; exit 1" INT
	fi

	opts_loop=:
	while ${opts_loop}; do
		read_char

		if [ "${opts_input}" = "$(printf '\033')" ]; then
		 	read_char
		 	read_char
		 	case ${opts_input} in
		 		"A") opts_input="k";;
		 		"B") opts_input="j";;
		 		"C") opts_input="l";;
		 		"D") opts_input="h";;
		 	esac
		fi

		case ${opts_input} in
		 	"h")
				if [ ${opts_chosen_tab} -ne 1 ]; then
					opts_chosen_tab=$((opts_chosen_tab - 1))
					opts_chosen_line=1
				fi ;;
		 	"l")
				if [ ${opts_chosen_tab} -ne ${opts_tab_count} ]; then
					opts_chosen_tab=$((opts_chosen_tab + 1))
					opts_chosen_line=1
				fi ;;
		 	"k") opts_chosen_line=$((opts_chosen_line - (opts_chosen_line != 1))) ;;
		 	"j") opts_chosen_line=$((opts_chosen_line + (opts_chosen_line != opts_height))) ;;

			"q") opts_loop=false ;;

			" "|${newline}||"") IFS=${newline} opts_select ;;
		esac
		IFS=${newline} opts_print
	done
	[ "${stty_settings+x}" ] && stty "${stty_settings}"
	unset opts_loop
}


opts_run() {
	get_cols
	for opt in ${opts}; do
		[ "${opt%% \[X\]*}" ] && continue
		printf '\n'
		i=0
		while [ ${i} -ne ${COLUMNS:-$(tput cols)} ]; do
			printf '━'
			i=$((i + 1))
		done
		opt_tmp_str=${opt# \[?\] }
		opt_tmp_str=${opt_tmp_str% \\033*}
		printf "\r\033[$(((${COLUMNS:-$(tput cols)} - ${#opt_tmp_str}) / 2))C %s \n" "${opt_tmp_str}"
		unset i opt_tmp_str
		${opt##*\|}
	done
}



notice "If the terminal acts weird, please run 'stty icanon'"
printf '\n'
IFS=${newline} opts_setup
IFS=${newline} opts_print
opts_handle_keypress


[ "${opts+x}" ] || exit 0
IFS=${newline} opts_run
