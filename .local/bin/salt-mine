#!/bin/python

# Salt-Mine: Mine, my salty dotfiles from salt rocks
#
# This script is basically just a migration script using
# curses that makes migrating my *personal* dotfiles easier


# TODO #
# - Check for internet connection
# - Check if the operating system is supported
# - Make the script compatible with python2
# TEST

import os

# Variables #
message = (
        "Underline means the dependency or dependencies are not meant.",
        "k: UP  j: DOWN,  a: Select All or arrow keys",
        "G: Go to bottom  g: Go to Top"
    )

home      = os.environ["HOME"]
dotDir    = home + "/.local/dots"
dotBackup = home + "/dotBackup"
dotURL    = "https://gitlab.com/Smeueg/Dotfiles.git"

wallpaperDir = home + "/.local/rice/wallpapers"
wallpapers   = {
        "Rock Thing.png" : "https://images2.alphacoders.com/950/950452.png"
}

sucklessDir = home + "/.local/rice"
fontsDir    = home + "/.local/share/fonts"

# Utilities #
def DownloadFile(url, file):
    from urllib.request import Request, urlopen

    if file[-1] == "/":
        file += url.split("/")[-1]

    req = Request(url, headers={'User-Agent': 'Mozilla/5.0'})

    with open(file, 'wb') as f:
        f.write(urlopen(req).read())


def Confirm(string):
    if not string.endswith("[Y/n] "):
        if string[-1] != " ":
            string += " "
        string += "[Y/n] "

    confirmation = input(string).lower()

    if confirmation == "" or confirmation == "y" or confirmation == "yes":
        return True

    return False


def GithubRegex(repoUrl, regex):
    from urllib.request import Request, urlopen
    import re
    if repoUrl[-1] != "/":
        repoUrl += "/"

    repoUrl = Request(repoUrl + "releases", headers={"User-Agent": "Mozilla/5.0"})
    repoUrl = urlopen(repoUrl).read().decode()

    latestTag = re.findall("(?<=/releases/tag/).*(?=\")", repoUrl)[0]

    files = []
    for file in re.findall('(?<=href="){}(?=")'.format(regex), repoUrl):
        if latestTag in file:
            files.append("https://github.com" + file)

    return files


# UI
import curses
stdscr = None
menu   = None


def drawMsg(menuY):
    global stdscr
    if stdscr == None:
        stdscr = curses.initscr()

    msgAmount = len(message)
    for i in range(msgAmount):
        stdscr.addstr(int(menuY-msgAmount+i), int((stdscr.getmaxyx()[1] - len(message[i])) / 2), message[i])

    stdscr.refresh()


def drawMenu(choices, isSubmenu):
    global stdscr
    global menu

    menuH = len(choices)
    menuW = 0

    for choice in choices:
        if len(choice.name) > menuW:
            menuW = len(choice.name)

    if stdscr == None:
        stdscr = curses.initscr()

    menuH += 2
    menuW += 7
    menuY = (stdscr.getmaxyx()[0] - menuH) / 2
    menuX = (stdscr.getmaxyx()[1] - menuW) / 2

    if menu == None:
        menu = curses.newwin(0, 0)
        menu.keypad(True)

    menu.resize(menuH, menuW)
    menu.mvwin(int(menuY), int(menuX))
    menu.box()
    drawMsg(menuY)

    highlighted = 0
    while True:
        highlightedOffset = 1

        for index in range(menuH - 1):
            attr = [curses.A_NORMAL, curses.A_REVERSE][highlighted == index]

            if index != len(choices):
                offset = 1
                choice = choices[index]

                if choice.missingDep["progs"] != [] or choice.missingDep["libs"] != []:
                    attr = attr | curses.A_UNDERLINE

                if choice.submenu == None:
                    string = "[" + [" ", "X"][choices[index].toggled] + "]"
                else:
                    string = " * "

                string += " " + choices[index].name + " "
            else:
                string = [" CONTINUE ", " BACK "][isSubmenu]
                offset = int((menuW - len(string)) / 2)

            if highlighted == index:
                highlightedOffset = offset

            menu.addstr(index + 1, offset, string, attr)

        menu.move(highlighted+1, highlightedOffset)

        key = menu.getkey()


        if key == "j" or key == "KEY_DOWN":
            highlighted += (highlighted != menuH-2)

        elif key == "k" or key == "KEY_UP":
            highlighted -= (highlighted != 0)

        elif key == "g":
            highlighted = 0

        elif key == "G":
            highlighted = menuH - 2

        elif key == "q":
            curses.endwin()
            exit(1)

        elif key == "a":
            selectedAll = True
            for choice in choices:
                if not choice.toggled and not choice.submenu:
                    selectedAll = False
                    break

            for choice in choices:
                if choice.submenu == None:
                    choice.toggled = not selectedAll

        elif key == "\n" or key == " " or key == "KEY_RIGHT":
            if highlighted == menuH-2:
                menu.clear()
                menu.refresh()
                return True

            if choices[highlighted].missingDep["progs"] != [] or choices[highlighted].missingDep["libs"]:
                continue

            if choices[highlighted].submenu == None:
                choices[highlighted].toggled = not choices[highlighted].toggled
            else:
                menu.clear()
                menu.refresh()
                stdscr.clear()
                stdscr.refresh()
                drawMenu(choices[highlighted].submenu, True)
                stdscr.clear()
                menu.clear()
                menu.resize(menuH, menuW)
                menu.mvwin(int(menuY), int(menuX))
                menu.box()
                drawMsg(menuY)

        elif key == "KEY_LEFT":
            menu.clear()
            menu.refresh()
            return True



# Main Code #
class Choice:
    def __init__(self, name, submenu, func, arg, deps):
        self.name    = name
        self.submenu = submenu
        self.func    = func
        self.arg     = arg
        self.deps    = deps
        self.toggled = False


        # Dependency Checking #
        self.missingDep = {
            "progs" : [],
            "libs"  : []
        }

        if self.deps != None:
            progs = self.deps.get("progs")
            libs  = self.deps.get("libs")

            path = os.environ["PATH"]
            if progs != None:
                if type(progs) == str:
                    progs = [progs]

                for file in progs:
                    found = False
                    for directory in path.split(":"):
                        if directory[-1] != "/":
                            directory += "/"

                        if os.access(directory + file, os.X_OK):
                            found = True

                    if not found:
                        self.missingDep["progs"].append(file)

            if libs != None:
                import subprocess
                if type(libs) == str:
                    libs = [libs]

                for lib in libs:
                    err = subprocess.run(["cc", "-l" + lib], capture_output=True, text=True)

                    if "cannot find -l" + lib in err.stderr:
                        self.missingDep["libs"].append("lib" + lib)


    def execute(self):
        if self.func == None and self.submenu == None:
            return

        submenuExec = False
        if self.submenu != None:
            for choice in self.submenu:
                if choice.toggled:
                    choice.execute()
                    submenuExec = True

        if (self.toggled or submenuExec) and self.func != None:
            if self.arg == None:
                self.func()
            else:
                self.func(self.arg)


def CheckDep(choices):
    print("Checking dependencies...")
    missing = {}

    def CheckMenu(menu, prevMenu):
        for choice in menu:
            for depType in choice.missingDep:
                for dep in choice.missingDep[depType]:
                    string = choice.name

                    if prevMenu != None:
                        string += "\033[4m\033[1m\033[3m in \033[0m" + prevMenu.name

                    if missing.get(dep) == None:
                        missing[dep] = [string]
                    else:
                        missing[dep].append(string)

            if choice.submenu != None:
                CheckMenu(choice.submenu, choice)

    CheckMenu(choices, None)

    if missing == {}:
        return True

    print("!! WARNING !!")
    for dep in missing:
        print(dep + " is needed to install:")
        for name in missing[dep]:
            print("  - " + name)
        print("")

    return Confirm("Do you want to continue?")
# --------- #


# Dotfiles #
def getDot():
    if os.path.isdir(dotDir):
        print("Target directory exists, Will not install dotfiles...")
        return

    import subprocess
    print("\n\nDownloading dotfiles...")
    os.system("git clone --bare {} {}".format(dotURL, dotDir))

    output = subprocess.run(["git", "--git-dir=" + dotDir, "ls-tree", "-r", "HEAD"], capture_output=True, text=True)
    output = output.stdout

    for line in output.splitlines():
        file = line.split("\t")[1]

        if os.path.isfile(home + "/" + file):
            import shutil

            directory = dotBackup + "/" + "/".join(file.split("/")[:-1])
            if not os.path.isdir(directory):
                os.makedirs(directory)
                print("Made directory: " + directory)

            shutil.move(home + "/" + file, directory)

    os.system("git --git-dir={} --work-tree={} checkout".format(dotDir, home))
    os.system("git --git-dir={} config status.showUntrackedFiles no".format(dotDir))
    print("Downloaded dotfiles!")
# -------- #



# Wallpapers #
def getWallpapers():
    global wallpaperDir

    print("Getting wallpaper(s)")
    if not os.path.isdir(wallpaperDir):
        print("Made directory: " + wallpaperDir)
        os.makedirs(wallpaperDir)

    if wallpaperDir[-1] != "/":
        wallpaperDir += "/"

    for file in wallpapers:
        DownloadFile(wallpapers[file], wallpaperDir + file)
        print("Downloaded " + file)
# ---------- #


# Suckless #
def GetSuckless(arg):
    if type(arg) == str:
        url     = arg
        regex   = None
        patches = None
    else:
        url     = arg[0]
        regex   = arg[1]
        patches = arg[2]

    if regex != None:
        url = GithubRegex(url, regex)[0]


    print("Downloading {}...".format(url.split("/")[-1]))
    dest = url.split("/")[-1]
    if url.endswith(".git"):
        dest      = dest[:-4]
        dest      = sucklessDir + "/" + dest
        patchDest = dest
        os.system("git clone {} {}".format(url, dest))

    elif url.endswith(".tar.gz"):
        from urllib.request import Request, urlopen
        from io import BytesIO
        import tarfile
        tar = Request(url, headers={"User-Agent": "Mozilla/5.0"})
        tar = urlopen(tar).read()
        tar = tarfile.open(fileobj=BytesIO(tar))

        dirAmount = 0
        for member in tar.getmembers():
            if member.isdir():
                dirAmount += 1

        if dirAmount == 1:
            dest = sucklessDir
            patchDest = sucklessDir + "/" + tar.getmembers()[0].name
        else:
            dest      = sucklessDir + dest[:-7]
            patchDest = dest

        if not os.path.isdir(dest):
            os.makedirs(dest)

        tar.extractall(dest)
        tar.close()
    else:
        return

    if patches == None:
        return

    if patchDest[-1] != "/":
        patchDest += "/"

    for patch in patches:
        DownloadFile(patch, patchDest)
        os.system("patch -d {} < {}".format(patchDest, patchDest + "/" + patch.split("/")[-1]))


def CompileSuckless():
    if Confirm("Do you with to compile all of your suckless Utilities (You need root privilages)?"):
        import termios
        import sys
        fd = sys.stdin.fileno()
        default = termios.tcgetattr(fd)
        os.system("su -c 'for dir in {}/*/*[Mm]akefile; do make install -C $(dirname $dir); done'".format(sucklessDir))
        termios.tcsetattr(fd, termios.TCSADRAIN, default)
# -------- #





# Fonts #
def getFonts(arg):
    from urllib.request import Request, urlopen
    from zipfile import ZipFile
    from io import BytesIO
    url       = [arg[0]]
    regex     = arg[1]
    directory = arg[2]


    if directory == None or directory == "":
        directory = fontsDir
    else:
        directory = fontsDir + "/" + directory

    if directory[-1] != "/":
        directory += "/"

    if not os.path.isdir(directory):
        os.makedirs(directory)

    if regex != "" and regex != None:
        url = GithubRegex(url[0], regex)

    for file in url:
        print("Downloading {}...".format(file.split("/")[-1]))
        if file.endswith(".zip"):
            zipData = Request(file, headers={"User-Agent": "Mozilla/5.0"})
            zipData = urlopen(zipData)
            zipData = ZipFile(BytesIO(zipData.read()))
            zipData.extractall(directory)
        else:
            DownloadFile(file, directory)




suckless = (
    Choice("Dynamic Window Manager", None, GetSuckless, "https://gitlab.com/Smeueg/dwm.git",
        {"progs":"git","libs":["X11", "Xinerama", "fontconfig", "Xft"]}),

    Choice("Simple Terminal", None, GetSuckless, "https://gitlab.com/Smeueg/st.git",
        {"progs":"git","libs":["X11", "Xft", "Xrender"]}),

    Choice("DwmBlocks", None, GetSuckless, "https://gitlab.com/Smeueg/dwmblocks.git",
        {"progs":"git","libs":"X11"}),

    Choice("Herbe", None, GetSuckless, [
            "https://github.com/dudik/herbe",
            ".*.tar.gz",
            (
                "https://patch-diff.githubusercontent.com/raw/dudik/herbe/pull/11.diff",
                "https://patch-diff.githubusercontent.com/raw/dudik/herbe/pull/19.diff"
            )
        ], {"progs":"patch","libs":["X11","Xft"]}),

    Choice("Devour", None, GetSuckless,
        ["https://github.com/salman-abedin/devour", ".*.tar.gz", None],
        {"libs":"X11"})
)

fonts = (
    Choice("JetBrains Mono", None, getFonts, (
            "https://github.com/JetBrains/JetBrainsMono",
            ".*JetBrainsMono\\-.*.zip",
            "JetBrainsMono"
        ),
        None),

    Choice("Material Icons", None, getFonts, (
            "https://github.com/google/material-design-icons/blob/master/font/MaterialIcons-Regular.ttf",
            None,
            None),
        None),
)

mainChoice = (
    Choice("Dotfiles",                  None,     getDot,          None, {"progs":"git"}),
    Choice("Wallpaper(s)",              None,     getWallpapers,   None, None),
    Choice("Suckless & Other Programs", suckless, CompileSuckless, None, {"progs":"make"}),
    Choice("Fonts",                     fonts,    None,            None, None)
)


if not CheckDep(mainChoice):
    exit(-1)

execute = drawMenu(mainChoice, False)
curses.endwin()

if execute:
    for choice in mainChoice:
        choice.execute()

